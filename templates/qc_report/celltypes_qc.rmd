# Celltype annotation results

This section details results from performing celltype annotation.
Two complementary methods were used to perform celltyping:

* [`SingleR`](https://bioconductor.org/packages/release/bioc/html/SingleR.html), which uses a reference-based approach.
The [`BlueprintEncode` reference](https://rdrr.io/github/LTLA/celldex/man/BlueprintEncodeData.html) from the [`celldex` package](http://bioconductor.org/packages/release/data/experiment/html/celldex.html) was used as the reference dataset.
This reference contains stroma and immune cells identified by Blueprint and Encode.
* [`CellAssign`](https://github.com/Irrationone/cellassign), which uses a marker-gene based approach.
Marker genes for celltyping were obtained from [PanglaoDB](https://panglaodb.se/).

Cells annotated as "Unknown cell type" represent cells which could not be confidently identified using the given annotation method. 

If available, these results will be compared to celltype annotations provided by the data's originating research group ("submitter-provided celltype annotations".)

## Celltype annotation summary

```{r}
# Create data frame of celltypes
celltype_df <- colData(processed_sce) |>
  as.data.frame() |>
  # barcodes to a column
  tibble::rownames_to_column(var = "barcode") |>
  # keep only cell name, celltyping, and clusters
  # note that `celltype_cols` was defined in the main qc_report.rmd
  dplyr::select(barcode, all_of(celltype_cols), clusters) |>
  # change NA/other to "Unknown cell type"
  dplyr::mutate(
    singler_celltype_annotation = ifelse(
      is.na(singler_celltype_annotation),
      "Unknown cell type", 
      singler_celltype_annotation
    ),
     cellassign_celltype_annotation = ifelse(
      cellassign_celltype_annotation == "other",
      "Unknown cell type", 
      cellassign_celltype_annotation
    )
  )
    
# Define a helper function to create tables for singler and cellassign annotations
create_celltype_n_table <- function(df, celltype_column) {
  df |>
    # create column with better name 
    dplyr::rename(`Annotated celltype` = {{celltype_column}}) |>
    dplyr::count(`Annotated celltype`) |>
    dplyr::arrange(-n) |>
    # make this column a factor with unknown at the end
    dplyr::mutate(
      # Add percentage column
      `Percent of cells` =  paste0(round(n/sum(n) * 100, digits = 2), "%"),
      # set column order in descending order of n, but with unknown at the end
      `Annotated celltype` = forcats::fct_reorder(`Annotated celltype`, n, .desc=TRUE),
      `Annotated celltype` = forcats::fct_relevel(`Annotated celltype`, 
                                                  "Unknown cell type", 
                                                   after = Inf)
    ) |>
    # arrange on `Annotated celltype`
    dplyr::arrange(`Annotated celltype`) |>
    # set column order
    dplyr::select(
      `Annotated celltype`,
      `Number of cells` = n,
      `Percent of cells`
    ) |>
    # kable formatting
    knitr::kable(align = 'r') |>
    kableExtra::kable_styling(bootstrap_options = "striped",
                             full_width = FALSE,
                             position = "left") |>
    kableExtra::column_spec(2, monospace = TRUE)
}
```

### `SingleR` celltype annotations

```{r}
create_celltype_n_table(celltype_df, singler_celltype_annotation)
```


### `CellAssign` celltype annotations

```{r}
create_celltype_n_table(celltype_df, cellassign_celltype_annotation)
```


```{r, eval = has_submitter_celltypes}
asis_output("### Submitter-provided celltype annotations\n")
# TODO: check column name once submitter annotations are actually added to workflow
create_celltype_n_table(celltype_df, submitter_celltype_annotation)
```


## Celltype annotations and clusters

Below, we show heatmaps comparing celltype annotations (along the y-axis) to clustering results (along the x-axis).
Clusters were obtained using the graph-based `r metadata(processed_sce)$cluster_algorithm` algorithm with `r metadata(processed_sce)$cluster_weighting` weights.

```{r}
# Helper function for making a heatmap
create_celltype_cluster_heatmap <- function(celltype_vector,
                                            cluster_vector, 
                                            title) {
  
  # Ensure factor order: descending order with unknown at the end
  celltype_vector <- celltype_vector |>
    forcats::fct_infreq() |>
    forcats::fct_relevel("Unknown cell type", after = Inf)
  
    # build a matrix with cluster identity as rows and celltype as columns
    label_mtx <- table(celltype_vector,
                       cluster_vector,
                       useNA = "ifany") |> 
      log1p() # log transform for visualization
    
    # heatmap
    ComplexHeatmap::pheatmap(label_mtx,
                       # TODO: cluster or specify row order based on number of cells?
                       cluster_rows = FALSE, 
                       cluster_cols = FALSE,
                       row_order = rownames(label_mtx), # use factor levels
                       row_names_side = "left", # show cell type labels on left
                       fontsize_col = 12,    # font size for clusters types
                       fontsize_row = 7,    # font size for celltypes
                       angle_col = "0", # don't rotate column names (clusters)
                       heatmap_legend_param = list(title = "Log(Number of cells)", 
                                                   legend_height = unit(4, "cm")),
                       main = title)
}
```


```{r fig.height=5, fig.width=7}
create_celltype_cluster_heatmap(
  celltype_df$singler_celltype_annotation, 
  celltype_df$clusters, 
  "SingleR annotations"
)

create_celltype_cluster_heatmap(
  celltype_df$cellassign_celltype_annotation, 
  celltype_df$clusters, 
  "CellAssign annotations"
)
```

```{r, eval = has_submitter_celltypes, fig.height=5, fig.width=7}
create_celltype_cluster_heatmap(
  celltype_df$submitter_celltype_annotation, 
  celltype_df$clusters, 
  "Submitter-provided annotations"
)

```

