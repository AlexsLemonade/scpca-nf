# Cell type Annotation Summary

This section details results from performing cell type annotation.
The following method(s) were used to perform cell typing:

<!-- Background depends on which cell type methods were used -->

```{r, eval = has_singler}
knitr::asis_output(
  glue::glue(
  "* [`SingleR`](https://bioconductor.org/packages/release/bioc/html/SingleR.html), which uses a reference-based approach.
  The `{metadata(processed_sce)$singler_reference}` reference dataset, obtained from the [`celldex` package](http://bioconductor.org/packages/release/data/experiment/html/celldex.html) package, was used for cell typing."
  )
)
```


```{r, eval = has_cellassign}
knitr::asis_output(
  glue::glue(
  "
  * [`CellAssign`](https://github.com/Irrationone/cellassign), which uses a marker-gene based approach.
  Marker genes associated with `{metadata(processed_sce)$cellassign_reference}` tissue were obtained from [PanglaoDB](https://panglaodb.se/).
  ")
)
```


Cells annotated as "Unknown cell type" represent cells which could not be confidently identified using the given annotation method. 

If available, these results will be compared to cell type annotations provided by the data's originating research group ("submitter-provided cell type annotations".)

## Cell type Annotation Statistics

```{r}
# Create data frame of cell types
celltype_df <- colData(processed_sce) |>
  as.data.frame() |>
  # barcodes to a column
  tibble::rownames_to_column(var = "barcode") |>
  # keep only cell name, celltyping, and clusters
  dplyr::select(barcode, 
                clusters,
                contains("singler"),
                contains("cellassign"))

# Reformat NA (singler) and other (cellassign) to "Unknown cell type"
if (has_singler) {
celltype_df <- celltype_df |>
  dplyr::mutate(
    singler_celltype_annotation = ifelse(
      is.na(singler_celltype_annotation),
      "Unknown cell type", 
      singler_celltype_annotation
    )
  )
}
if (has_cellassign) {
  celltype_df <- celltype_df |>
    dplyr::mutate(
     cellassign_celltype_annotation = ifelse(
      cellassign_celltype_annotation == "other",
      "Unknown cell type", 
      cellassign_celltype_annotation
    )
  )
}
    
# Define a helper function to create tables for singler and cellassign annotations
create_celltype_n_table <- function(df, celltype_column) {
  df |>
    # rename column with user-facing name 
    dplyr::rename(`Annotated cell type` = {{celltype_column}}) |>
    dplyr::count(`Annotated cell type`) |>
    # make this column a factor with unknown at the end
    dplyr::mutate(
      # Add percentage column
      `Percent of cells` =  paste0(round(n/sum(n) * 100, digits = 2), "%"),
      # set column order in descending order of n, but with unknown at the end
      `Annotated cell type` = forcats::fct_reorder(`Annotated cell type`, n, .desc=TRUE),
      `Annotated cell type` = forcats::fct_relevel(`Annotated cell type`, 
                                                  "Unknown cell type", 
                                                   after = Inf)
    ) |>
    # arrange on `Annotated cell type` now that factor levels have been specified
    dplyr::arrange(`Annotated cell type`) |>
    # set column order
    dplyr::select(
      `Annotated cell type`,
      `Number of cells` = n,
      `Percent of cells`
    ) |>
    # kable formatting
    knitr::kable(align = 'r') |>
    kableExtra::kable_styling(bootstrap_options = "striped",
                             full_width = FALSE,
                             position = "left") |>
    kableExtra::column_spec(2, monospace = TRUE)
}
```



```{r, eval = has_singler}
knitr::asis_output("### `SingleR` cell type annotations\n")
create_celltype_n_table(celltype_df, singler_celltype_annotation)
```

```{r, eval = has_cellassign}
knitr::asis_output("### `CellAssign` cell type annotations\n")
create_celltype_n_table(celltype_df, cellassign_celltype_annotation)
```

```{r, eval = has_submitter_celltypes}
knitr::asis_output("### Submitter-provided cell type annotations\n")
# Note: submitter annotations have not yet been added to the workflow, 
#  so this variable name `submitter_celltype_annotation` is just a placeholder
create_celltype_n_table(celltype_df, submitter_celltype_annotation)
```





## Cell type annotations and clusters


### UMAPs

In this section, we show UMAPs colored by clusters and cell types.
A separate UMAP is shown for each cell typing method used.
Clusters were calculated using the graph-based `r metadata(processed_sce)$cluster_algorithm` algorithm with `r metadata(processed_sce)$cluster_weighting` weights.

For legibility, only the seven most common cell types are shown.
All other cell types are grouped together and labeled "Other cell type" (not to be confused with "Unknown cell types," which represent cells that could not be classified).


```{r}
# Create dataset for plotting UMAPs with lumped cell types
umap_df <- tibble::tibble(
  UMAP1 = unname(reducedDim(processed_sce, "UMAP")[,1]),
  UMAP2 = unname(reducedDim(processed_sce, "UMAP")[,2]),
  clusters = processed_sce$clusters
)

# helper function for lumping cell types
lump_celltypes <- function(umap_df, 
                           orginal_column_string, 
                           new_column, 
                           n_celltypes = 7) {
  umap_df |>
    dplyr::mutate({{new_column}} := celltype_df[[orginal_column_string]],
                  # lump the top 10
                  {{new_column}} := forcats::fct_lump_n({{new_column}},
                                                        n_celltypes, 
                                                        other_level = "Other cell type")
                  )
}

if (has_singler) {
  umap_df <- lump_celltypes(umap_df, "singler_celltype_annotation", singler)
}
if (has_cellassign) {
  umap_df <- lump_celltypes(umap_df, "cellassign_celltype_annotation", cellassign)
}
# Note that later, we will want to do this with submitter cell types too, if present.
```


```{r}
# Define helper function for making UMAPs in this section
#  this function uses the default palette, which can be customized when
#  calling the function
plot_umap <- function(umap_df, 
                      color_variable,
                      legend_title, 
                      legend_nrow = 2) {
  
  ggplot(umap_df) + 
    aes(x = UMAP1, 
        y = UMAP2, 
        color = {{color_variable}}) + 
    geom_point(size = 0.3,
               alpha = 0.5) + 
    # remove axis numbers and background grid
    scale_x_continuous(labels = NULL, breaks = NULL) + 
    scale_y_continuous(labels = NULL, breaks = NULL) + 
    coord_fixed() + 
    guides(
      color = guide_legend(title = legend_title, 
                           nrow = legend_nrow,
                           # more visible points in legend
                           override.aes = list(alpha = 1,
                                               size = 1.5))) + 
    theme(legend.position = "bottom")
}
```

<!-- First UMAP: clusters --> 
```{r message=FALSE, warning=FALSE}
clusters_plot <- plot_umap(umap_df, 
          clusters,
          "Clusters") +
  ggtitle("UMAP colored by clusters")

# Determine palette based on number of levels.
# If we have <=8, we can use a CVD-friendly palette (they generally don't have more than 8 colors). 
#  Otherwise, we will use the default palette.
if (length(levels(umap_df$clusters)) <= 8) {
  clusters_plot + 
    scale_color_brewer(palette =  "Set2")
} else {
  clusters_plot
}
  
```

<!-- Now, UMAPs of cell types, where present -->

```{r eval=has_singler, message=FALSE, warning=FALSE}
plot_umap(umap_df, 
          singler,
          "Cell types",
          legend_nrow = 4) +
  ggtitle("UMAP colored by SingleR annotations") + 
  scale_color_brewer(palette = "Dark2")
```


```{r, eval = has_cellassign, message=FALSE, warning=FALSE}
plot_umap(umap_df, 
          cellassign,
          "Cell types",
          legend_nrow = 4) +
  ggtitle("UMAP colored by CellAssign annotations")  + 
  scale_color_brewer(palette = "Dark2")
```


```{r eval=has_submitter_celltypes, message=FALSE, warning=FALSE}
# Nothing in this chunk yet - it's a placeholder
```

### Heatmaps

Below, we show heat maps comparing cell type annotations (along the y-axis) to clustering results (along the x-axis).
Heatmap colors represent the log number of cells present in both the given cell type and cluster.


```{r}
# Helper function for making a heatmap
create_celltype_cluster_heatmap <- function(celltype_vector,
                                            cluster_vector) {
  
  # build a matrix with cluster identity as rows and celltype as columns
  celltype_cluster_mtx <- table(celltype_vector,
                                cluster_vector) |> 
    log1p() # log transform for visualization
    
  # Define CVD-friendly palette 
  heatmap_palette <- viridisLite::inferno(7, alpha = 1, begin = 0, end = 1, direction = 1)
  
  # heatmap
  heat <- ComplexHeatmap::Heatmap(celltype_cluster_mtx,
                                  # Overall heatmap parameters
                                  col = heatmap_palette,
                                  # Column parameters
                                  column_title = "Clusters",
                                  column_title_side = "bottom", 
                                  column_dend_side = "top",
                                  column_names_rot = 0,
                                  # Row parameters
                                  row_dend_side = "left",
                                  row_names_gp = grid::gpar(fontsize = 8),
                                  # Legend parameters
                                  heatmap_legend_param = list(
                                    title = "Log(Number of cells)",
                                    title_position = "leftcenter-rot",
                                    legend_height = unit(4, "cm")
                                    )
                                  )
  # draw with legend on left for spacing
  ComplexHeatmap::draw(heat, heatmap_legend_side = "left")
}
```


```{r, eval = has_singler, fig.height=5, fig.width=7}
knitr::asis_output("### `SingleR` cluster and cell type heatmap\n")
create_celltype_cluster_heatmap(
  celltype_df$singler_celltype_annotation, 
  celltype_df$clusters
)
```

```{r, eval = has_cellassign, fig.height=5, fig.width=7}
knitr::asis_output("### `CellAssign` cluster and cell type heatmap\n")
create_celltype_cluster_heatmap(
  celltype_df$cellassign_celltype_annotation, 
  celltype_df$clusters
)
```

```{r, eval = has_submitter_celltypes, fig.height=5, fig.width=7}
knitr::asis_output("### Submitter-provided cluster and cell type heatmap\n")
create_celltype_cluster_heatmap(
  celltype_df$submitter_celltype_annotation, 
  celltype_df$clusters
)
```
