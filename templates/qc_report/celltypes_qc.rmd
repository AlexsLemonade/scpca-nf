# Cell type Annotation Summary

This section details results from performing cell type annotation.
The following method(s) were used to perform cell typing:

<!-- Background depends on which cell type methods were used -->

```{r, eval = has_singler}
knitr::asis_output(
  glue::glue(
  "* [`SingleR`](https://bioconductor.org/packages/release/bioc/html/SingleR.html), which uses a reference-based approach.
  The `{metadata(processed_sce)$singler_reference}` reference dataset, obtained from the [`celldex` package](http://bioconductor.org/packages/release/data/experiment/html/celldex.html) package, was used for cell typing."
  )
)
```


```{r, eval = has_cellassign}
knitr::asis_output(
  glue::glue(
  "
  * [`CellAssign`](https://github.com/Irrationone/cellassign), which uses a marker-gene based approach.
  Marker genes associated with `{metadata(processed_sce)$cellassign_reference}` tissue were obtained from [PanglaoDB](https://panglaodb.se/).
  ")
)
```


Cells annotated as "Unknown cell type" represent cells which could not be confidently identified using the given annotation method. 

If available, these results will be compared to cell type annotations provided by the data's originating research group ("submitter-provided cell type annotations".)

## Cell type Annotation Statistics

```{r}
# This chunk defines a helper function to reformat annotations:
#  * Annotations that are `NA`/"other" are changed to "Unknown cell type" 
#  * Annotations are converted to a factor ordered by frequency, but with 
#    "Unknown cell type" always last.
prepare_annotation_values <- function(df, annotation_column) {
  df |>
    dplyr::mutate(
      {{annotation_column}} := dplyr::case_when(
        # singler condition
        is.na({{annotation_column}}) ~ "Unknown cell type",
        # cellassign conditon
        {{annotation_column}} == "other" ~ "Unknown cell type",
        # otherwise, keep it
        TRUE ~ {{annotation_column}}
      ) |>
      forcats::fct_infreq() |>
      forcats::fct_relevel("Unknown cell type", after = Inf)
    )
}
```

```{r}
# Create data frame of cell types
celltype_df <- colData(processed_sce) |>
  as.data.frame() |>
  # barcodes to a column
  tibble::rownames_to_column(var = "barcode") |>
  # keep only cell name, celltyping, and clusters
  dplyr::select(barcode, 
                clusters,
                contains("singler"),
                contains("cellassign"))



if (has_singler) {
  celltype_df <- celltype_df |>
    prepare_annotation_values(singler_celltype_annotation)
}
if (has_cellassign) {
  celltype_df <- celltype_df |>
    prepare_annotation_values(cellassign_celltype_annotation)
} 
```

```{r}
# Define a helper function to create tables for singler and cellassign annotations
create_celltype_n_table <- function(df, celltype_column) {
  df |>
    dplyr::count({{celltype_column}}) |>
    # Add percentage column
    dplyr::mutate(
      `Percent of cells` =  paste0(round(n/sum(n) * 100, digits = 2), "%")
    ) |>
    # set column order & rename
    dplyr::select(
      `Annotated cell type` = {{celltype_column}},
      `Number of cells` = n,
      `Percent of cells`
    ) |>
    # kable formatting
    knitr::kable(align = 'r') |>
    kableExtra::kable_styling(bootstrap_options = "striped",
                             full_width = FALSE,
                             position = "left") |>
    kableExtra::column_spec(2, monospace = TRUE)
}
```



```{r, eval = has_singler}
knitr::asis_output("### `SingleR` cell type annotations\n")
create_celltype_n_table(celltype_df, singler_celltype_annotation)
```

```{r, eval = has_cellassign}
knitr::asis_output("### `CellAssign` cell type annotations\n")
create_celltype_n_table(celltype_df, cellassign_celltype_annotation)
```

```{r, eval = has_submitter_celltypes}
knitr::asis_output("### Submitter-provided cell type annotations\n")
# Note: submitter annotations have not yet been added to the workflow, 
#  so this variable name `submitter_celltype_annotation` is just a placeholder
create_celltype_n_table(celltype_df, submitter_celltype_annotation)
```


## Cell type annotation assessment

In this section, we assess the reliability of cell type annotations using diagnostic plots.


```{r, eval = has_singler}
knitr::asis_output("
### `SingleR` assessment

`SingleR` assigns cell type scores based on Spearman correlations across features in the reference dataset.
We evaluate the reliability of cell type annotations using the per-cell _delta median_ statistic, which is the difference between the score for the cell's assigned label and the median score of all labels for the given cell.
Higher _delta median_ values indicate more confidence in the cell type annotation, although there is no specific threshold for calling absolute high vs. low confidence.
For more information, refer to the [`SingleR` book section on 'Annotation diagnostics'](https://bioconductor.org/books/release/SingleRBook/annotation-diagnostics.html#annotation-diagnostics).


In the plot below, each point is the _delta median_ statistic of a given cell with the given cell type annotation. 
Points (cells) are colored by `SingleR`'s internal confidence assessment: High-quality cell annotations are shown in black, and low-quality cell annotations are shown in blue.
All blue points correspond to cells labeled as `Unknown cell type` in the `SingleR` result table in the previous section.
The red overlayed boxes represent the median Â± interquartile range (IQR), specifically for high-quality annotations.
")
```


```{r, eval = has_singler, warning=FALSE, message=FALSE,fig.height = 6, fig.width = 8}
# Prepare SingleR scores for plot

# extract scores into matrix
singler_scores <- metadata(processed_sce)$singler_result$scores 

# Create data frame for plotting with delta median and the full *non-pruned* cell labels
delta_median_df <- tibble::tibble(
  delta_median = rowMaxs(singler_scores) - rowMedians(singler_scores),
  # Need to grab the non-pruned label for this plot
  full_labels = metadata(processed_sce)$singler_result$labels,
  # TRUE pruned values ==> low confidence
  # so, negate for this variable:
  confident = !is.na(metadata(processed_sce)$singler_result$pruned.labels)
)

# If ontologies were used for `full_labels`, we'll need to map back to cell names
#  for the plot itself.
if ("singler_celltype_ontology" %in% names(celltype_df)) {

  # we use inner_join b/c the above tibble does NOT contain "Unknown cell type", which
  #  we do not want to display here
  delta_median_df <- delta_median_df |>
   dplyr::inner_join(
    tibble::tibble(
      full_labels = celltype_df$singler_celltype_ontology,
      celltype = celltype_df$singler_celltype_annotation
    ) |> dplyr::distinct()
  ) |>
    dplyr::select(-full_labels)
} else {
  # otherwise, full_labels already contain what we want to plot, so just rename it 
  delta_median_df <- delta_median_df |>
    dplyr::rename(celltype = full_labels)
}

# Ensure we have no "Unknown cell type" values left:
if (sum(delta_median_df$celltype == "Unknown cell type") > 0) {
  stop("Failed to process SingleR data for diagnostic plot.")
}

# add column with ordered levels with wrapped labels for visualization
delta_median_df$annotation_wrapped <- factor(
  delta_median_df$celltype,
  levels = levels(delta_median_df$celltype),
  labels = stringr::str_wrap(levels(delta_median_df$celltype), 30)
)

# Subset the data to just confident points for median+/-IQR
delta_median_confident_df <- delta_median_df |>
  dplyr::filter(confident)
 
# Plot delta_median across celltypes colored by pruning
ggplot(delta_median_df) + 
  aes(x = annotation_wrapped, 
      y = delta_median, 
      color = confident) + 
  ggforce::geom_sina(size = 0.75, 
                     alpha = 0.5, 
                     # Keep red points mostly in line with black
                     position = position_dodge(width = 0.05)) +
  labs(
    x = "Cell type annotation",
    y = "Delta median statistic",
    color = "Confident cell type assignment"
  ) + 
  scale_color_manual(values = c("blue", "black")) +
  # add median/IQR
  stat_summary(
    data = delta_median_confident_df, # only use black points for median
    color = "red",
    geom = "crossbar",
    width = 0.4,
    size = 0.2
  ) + 
  guides(
    color = guide_legend(override.aes = list(size = 1, alpha = 0.9))
  ) +
  theme(
    axis.text.x = element_text(angle = 55, hjust = 1, size = rel(0.85)), 
    legend.title = element_text(size = rel(0.75)),
    legend.text = element_text(size = rel(0.75)),
    legend.position = "bottom"
  )
```

## Cell type annotations and clusters


### UMAPs

In this section, we show UMAPs colored by clusters and cell types.
A separate UMAP is shown for each cell typing method used.
Clusters were calculated using the graph-based `r metadata(processed_sce)$cluster_algorithm` algorithm with `r metadata(processed_sce)$cluster_weighting` weights.

For legibility, only the seven most common cell types are shown.
All other cell types are grouped together and labeled "Other cell type" (not to be confused with "Unknown cell types," which represent cells that could not be classified).


```{r}
# Create dataset for plotting UMAPs with lumped cell types
umap_df <- tibble::tibble(
  UMAP1 = unname(reducedDim(processed_sce, "UMAP")[,1]),
  UMAP2 = unname(reducedDim(processed_sce, "UMAP")[,2]),
  clusters = processed_sce$clusters
)

# helper function for lumping cell types
lump_celltypes <- function(umap_df, 
                           celltype_df,
                           celltype_method,
                           n_celltypes = 7) {
  
  umap_df |>
    dplyr::mutate(
      celltypes =  celltype_df[[glue::glue("{celltype_method}_celltype_annotation")]],
      celltypes = forcats::fct_lump_n(celltypes,
                                      n_celltypes, 
                                      other_level = "Other cell type")) |>
    # finally, rename temporary `celltypes` column to the provided method
    dplyr::rename({{celltype_method}} := celltypes)
}

if (has_singler) {
  umap_df <- lump_celltypes(umap_df, celltype_df, "singler")
}
if (has_cellassign) {
  umap_df <- lump_celltypes(umap_df, celltype_df, "cellassign")
}
# Note that later, we will want to do this with submitter cell types too, if present.
```


```{r}
# Define helper function for making UMAPs in this section
#  this function uses the default palette, which can be customized when
#  calling the function
plot_umap <- function(umap_df, 
                      color_variable,
                      legend_title, 
                      legend_nrow = 2) {
  
  ggplot(umap_df) + 
    aes(x = UMAP1, 
        y = UMAP2, 
        color = {{color_variable}}) + 
    geom_point(size = 0.3,
               alpha = 0.5) + 
    # remove axis numbers and background grid
    scale_x_continuous(labels = NULL, breaks = NULL) + 
    scale_y_continuous(labels = NULL, breaks = NULL) + 
    coord_fixed() + 
    guides(
      color = guide_legend(title = legend_title, 
                           nrow = legend_nrow,
                           # more visible points in legend
                           override.aes = list(alpha = 1,
                                               size = 1.5))) + 
    theme(legend.position = "bottom")
}
```

<!-- First UMAP: clusters --> 
```{r message=FALSE, warning=FALSE}
clusters_plot <- plot_umap(umap_df, 
          clusters,
          "Clusters") +
  ggtitle("UMAP colored by clusters")

# Determine palette based on number of levels.
# If we have <=8, we can use a CVD-friendly palette (they generally don't have more than 8 colors). 
#  Otherwise, we will use the default palette.
if (length(levels(umap_df$clusters)) <= 8) {
  clusters_plot + 
    scale_color_brewer(palette =  "Set2")
} else {
  clusters_plot
}
  
```

<!-- Now, UMAPs of cell types, where present -->

```{r eval=has_singler, message=FALSE, warning=FALSE}
plot_umap(umap_df, 
          singler,
          "Cell types",
          legend_nrow = 4) +
  ggtitle("UMAP colored by SingleR annotations") + 
  scale_color_brewer(palette = "Dark2")
```


```{r, eval = has_cellassign, message=FALSE, warning=FALSE}
plot_umap(umap_df, 
          cellassign,
          "Cell types",
          legend_nrow = 4) +
  ggtitle("UMAP colored by CellAssign annotations")  + 
  scale_color_brewer(palette = "Dark2")
```


```{r eval=has_submitter_celltypes, message=FALSE, warning=FALSE}
# Nothing in this chunk yet - it's a placeholder
```

### Heatmaps

Below, we show heat maps comparing cell type annotations (along the y-axis) to clustering results (along the x-axis).
Heatmap colors represent the log number of cells present in both the given cell type and cluster.


```{r}
# Helper function for making a heatmap
create_celltype_cluster_heatmap <- function(celltype_vector,
                                            cluster_vector) {
  
  # build a matrix with cluster identity as rows and celltype as columns
  celltype_cluster_mtx <- table(celltype_vector,
                                cluster_vector) |> 
    log1p() # log transform for visualization
    
  # Define CVD-friendly palette 
  heatmap_palette <- viridisLite::inferno(7, alpha = 1, begin = 0, end = 1, direction = 1)
  
  # heatmap
  heat <- ComplexHeatmap::Heatmap(celltype_cluster_mtx,
                                  # Overall heatmap parameters
                                  col = heatmap_palette,
                                  # Column parameters
                                  column_title = "Clusters",
                                  column_title_side = "bottom", 
                                  column_dend_side = "top",
                                  column_names_rot = 0,
                                  # Row parameters
                                  row_dend_side = "left",
                                  row_names_gp = grid::gpar(fontsize = 8),
                                  # Legend parameters
                                  heatmap_legend_param = list(
                                    title = "Log(Number of cells)",
                                    title_position = "leftcenter-rot",
                                    legend_height = unit(4, "cm")
                                    )
                                  )
  # draw with legend on left for spacing
  ComplexHeatmap::draw(heat, heatmap_legend_side = "left")
}
```


```{r, eval = has_singler, fig.height=5, fig.width=7}
knitr::asis_output("### `SingleR` cluster and cell type heatmap\n")
create_celltype_cluster_heatmap(
  celltype_df$singler_celltype_annotation, 
  celltype_df$clusters
)
```

```{r, eval = has_cellassign, fig.height=5, fig.width=7}
knitr::asis_output("### `CellAssign` cluster and cell type heatmap\n")
create_celltype_cluster_heatmap(
  celltype_df$cellassign_celltype_annotation, 
  celltype_df$clusters
)
```

```{r, eval = has_submitter_celltypes, fig.height=5, fig.width=7}
knitr::asis_output("### Submitter-provided cluster and cell type heatmap\n")
create_celltype_cluster_heatmap(
  celltype_df$submitter_celltype_annotation, 
  celltype_df$clusters
)
```
