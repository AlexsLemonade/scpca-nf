---
params:
  reference_s3: s3://nextflow-ccdl-results/scpca-prod/results
  comparison_s3: s3://nextflow-ccdl-results/scpca-staging/results
  project_id: "all"
  use_cache: false
title: "`scpca-nf` Metrics Comparison"
subtitle: "Project: `r params$project_id`"
author: "Childhood Cancer Data Lab"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    code_folding: hide
---

```{r setup}
#| include: false
library(ggplot2)

knitr::opts_chunk$set(
  echo = FALSE
)

use_cache <- params$use_cache && file.exists("metrics.rds")

set.seed(1234)
```

```{r}
# Functions
#| include: false

report_table <- function(df, options = list(), ...) {
  # pass standard settings for report to DT::datatable
  # df: data frame to display
  # options: list of options to pass to DT::datatable
  # ...: additional arguments to pass to DT::datatable
  default_opts <- list(
    scroller = TRUE,
    deferRender = TRUE,
    scrollY = 400,
    scrollCollapse = TRUE,
    language = list(search = "Filter:")
  )
  if (length(options) > 0) {
    # merge default options with user options
    opts <- modifyList(default_opts, options)
  } else {
    opts <- default_opts
  }
  DT::datatable(
    df,
    rownames = FALSE,
    extensions = "Scroller",
    options = opts,
    ...
  )
}
```

```{r, eval=!use_cache}
#| include: false
# get metrics files by scanning S3
if (tolower(params$project_id[1]) == "all") {
  metrics_regex <- "SCPCL[0-9]{6}_metrics.json$"
} else {
  metrics_regex <- paste0("(", params$project_id, ".+SCPCL[0-9]{6}_metrics.json$)", collapse = "|")
}

ref_metrics_files <- s3fs::s3_dir_ls(
  params$reference_s3,
  recurse = TRUE,
  regexp = metrics_regex
) |>
  s3fs::s3_file_url() # get signed URLs for reading

comp_metrics_paths <- s3fs::s3_dir_ls(
  params$comparison_s3,
  recurse = TRUE,
  regexp = metrics_regex
) |>
  s3fs::s3_file_url()
```

```{r, eval=!use_cache}
#| include: false
# read metrics files from S3
ref_data <- purrr::map(ref_metrics_files, \(url) {
  jsonlite::read_json(url, simplifyVector = TRUE)
}) |>
  purrr::list_transpose(default = NA) |>
  tibble::as_tibble()

comp_data <- purrr::map(comp_metrics_paths, \(url) {
  jsonlite::read_json(url, simplifyVector = TRUE)
}) |>
  purrr::list_transpose(default = NA) |>
  tibble::as_tibble()

# join the two data frames
metrics_df <- dplyr::full_join(
  ref_data,
  comp_data,
  by = c("project_id", "sample_id", "library_id"),
  suffix = c(".ref", ".comp")
)
# temporary write for testing
readr::write_rds(metrics_df, "metrics.rds")
```

```{r, eval=use_cache}
#| include: false
# temporary chunk for testing
metrics_df <- readr::read_rds("metrics.rds")
```


## Project and sample changes

```{r}
# filter to get added or removed samples
lib_changes <- metrics_df |>
  dplyr::filter(if_any(starts_with("mapped_reads"), is.na)) |>
  dplyr::mutate(
    added_removed = ifelse(is.na(mapped_reads.ref), "Added", "Removed")
  ) |>
  dplyr::select(
    project_id,
    sample_id,
    library_id,
    added_removed
  )
```

```{r}
# Text summary of added/removed libraries
if (nrow(lib_changes) == 0) {
  knitr::asis_output(
    "There are no added or removed libraries."
  )
} else {
  n_added <- sum(lib_changes$added_removed == "Added")
  n_removed <- sum(lib_changes$added_removed == "Removed")
  n_projects <- dplyr::n_distinct(lib_changes$project_id)

  glue::glue("
    Below is a table of added or removed samples and libraries.<br>
    There {ifelse(n_added == 1, 'is', 'are')} **{n_added}** added {ifelse(n_added == 1, 'library', 'libraries')} and
    **{n_removed}** removed {ifelse(n_removed == 1, 'library', 'libraries')}.

    These come from **{n_projects}** {ifelse(n_projects == 1, 'project', 'projects')}.


  ") |>
    knitr::asis_output()
}
```

```{r, eval = nrow(lib_changes) > 0}
report_table(
  lib_changes,
  colnames = c("Project", "Sample", "Library", "Added/Removed")
)
```


## Processing changes {.tabset}

```{r}
processing_fields <- c(
  "droplet_filtering_method",
  "normalization_method",
  "cell_filtering_method",
  "cluster_algorithm",
  "singler_reference",
  "cellassign_reference"
)

processing_changes <- metrics_df |>
  tidyr::drop_na(starts_with("mapped_reads")) |> # remove added/removed libraries
  dplyr::select(
    project_id,
    sample_id,
    library_id,
    starts_with(processing_fields)
  ) |>
  tidyr::pivot_longer(
    cols = starts_with(processing_fields),
    names_pattern = "(.+)\\.(ref|comp)$",
    names_to = c("field", ".value") # .value separates into `ref` and `comp` fields
  ) |>
  dplyr::filter(
    ref != comp
  )

has_processing_changes <- nrow(processing_changes) > 0
```

```{r}
# Text summary of processing changes
if (has_processing_changes) {
  knitr::asis_output(
    "All processing fields are the same between the reference and comparison runs."
  )
} else {
  n_projects <- dplyr::n_distinct(processing_changes$project_id)
  n_libraries <- dplyr::n_distinct(processing_changes$library_id)

  glue::glue("
    The tables below show the processing changes between the reference and comparison workflow runs.<br>
    There {ifelse(n_added == 1, 'is', 'are a total of')} **{n_libraries}** {ifelse(n_libraries == 1, 'library', 'libraries')} with processing changes
    from **{n_projects}** {ifelse(n_projects == 1, 'project', 'projects')}.
  ") |>
    knitr::asis_output()
}
```


```{r, eval=has_processing_changes}
knitr::asis_output("### Summary")
```

```{r, eval=has_processing_changes}
processing_summary <- processing_changes |>
  dplyr::count(
    field,
    ref,
    comp,
    name = "n_changed"
  )

report_table(
  processing_summary,
  colnames = c("Processing field", "Reference value", "Comparison value", "Number of libraries changed")
)
```


```{r, eval=has_processing_changes}
knitr::asis_output("### Detail")
```

```{r, eval=has_processing_changes}
report_table(
  processing_changes,
  colnames = c("Project", "Sample", "Library", "Field", "Reference value", "Comparison value")
)
```

## Changes in cell and read counts

### Cell count changes {.tabset}

For each sample, we will want to first compare:

- `unfiltered_cells`
- `filtered_cells`
- `processed_cells`
- `miqc_pass_count`
- `scpca_filter_count`
- `adt_scpca_filter_count`

If there are changes in any of those, we will report those, with prominent warnings for any large changes.
What defines a large change?
Perhaps start with a change > 0.5% of the total?
Alternatively, if we see a large fraction of samples changing, we would want to note that.
If there are any changes to the number of unfiltered cells, that should be highlighted, as we do not expect this to change between runs.

#### Summary
The main display item would be a summary table, in the first tab:

| Metric | Number of samples changed | % of samples changed | Mean % change |
| ----- | --------- | --------- | ---------------- |
| `scpca_filter_count` | 100 | 20 | -10 |

We will also include a plot with a histogram of the % changes for each metric where at least one sample changed.


#### Detail

A detail table of changed samples/metrics might then look like the following:

| Sample | Metric | Reference Value | Comparison Value | Change | % change |
| ------- | ---------------- | --------------- | ---------------- | ------ | -------- |
| `SCPCS999999` | `unfiltered_cells` | 1000 | 1005 | 5 | 0.5 |


### Read count changes {.tabset}

If there are changes in the cell counts, we expect changes in the read counts as well.
So we may only want to proceed with read count changes for samples where cell counts are unchanged.
Here again, I think we should warn/highlight any changes > 0.5% of the total.
Changes to unfiltered counts should also be highlighted, as we do not expect these to change between runs.

- `unfiltered_total_counts`
- `unfiltered_total_spliced`
- `unfiltered_expressed_genes`
- `filtered_total_counts`
- `filtered_total_spliced`
- `filtered_expressed_genes`
- `processed_total_counts`
- `processed_total_spliced`
- `processed_total_logcounts`
- `processed_expressed_genes`

We will also include changes in altExps using the following fields:

- `unfiltered_altexp_total`
- `filtered_altexp_total`
- `processed_altexp_total`

These will require a bit of extra processing, in that we will probably want to extract the altExp names and add those to the field names.
For example, we would want to use a field like `unfiltered_altexp_total_adt` in the comparison table.


Again, we would report only changed metrics, starting with a summary table:

| Metric | Number of samples changed | % of samples changed | Mean % change |
| ----- | --------- | --------- | ---------------- |
| `scpca_filter_count` | 100 | 20 | -10 |

We could then list individual samples with changes, similar to the cell count table.

## Analysis changes

### Highly variable genes

Here we will report changes in the sets of HVGs, both in the set of genes and the order.

### Clustering

Report changes in the number of clusters, as well as changes in the sizes of the assigned clusters.
We will ignore changes in the ordering of clusters by sorting by cluster size before comparisons.
As a summary statistic, we might use adjusted Rand index (ARI) or adjusted mutual information (AMI) to compare the two sets of clusters, reporting when we are well below 1.

### Cell type assignments

Report changes to the set of cell types assigned, and to the number of cells for each cell type.
This will include SingleR, CellAssign and consensus cell types, if present.

My initial thought is to use the Euclidean distance between the sets of cell type assignments here (since the assignment values do matter), though we could also look at ARI or AMI.


## Session Info
<details>
<summary>Click to expand</summary>
```{r}
sessionInfo()
```
</details>
