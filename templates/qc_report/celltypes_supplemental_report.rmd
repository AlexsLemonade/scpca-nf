---
params:
  library: Example
  processed_sce: NULL
  date: !r Sys.Date()
title: "`r glue::glue('ScPCA Cell type annotation supplemental QC report for {params$library}')`"
author: "Childhood Cancer Data Lab"
date: "`r params$date`"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
    number_sections: false
    code_download: true
---

```{r setup, message = FALSE, echo = FALSE}
# knitr options
knitr::opts_chunk$set(
  echo = FALSE
)

library(SingleCellExperiment)
library(ggplot2)

# Set default ggplot theme
theme_set(
  theme_bw() +
    theme(
      plot.margin = margin(rep(20, 4)),
      strip.background = element_rect(fill = "transparent")
    )
)
```

<!-- Import shared functions for cell type wrangling -->
```{r, child='utils/celltype_functions.rmd'}

```

<!-- Define helper functions for calculating Jaccard matrices --> 
```{r}
#' Function to calculate Jaccard similarity on two vectors
#'
#' @param vec1 First vector
#' @param vec2 Second vector
#'
#' @return Jaccard similarity between the vectors
jaccard <- function(vec1, vec2){
  length(intersect(vec1, vec2)) / length(union(vec1, vec2))
}


# Wrapper function to calculate jaccard similarity matrix for two categorical variables
#'
#' @param celltype_df The celltype_df data frame which must contain these columns:
#'   `colname1`, `colname2`, and `barcodes`
#' @param colname1 Column name, as a string, of first categorical variable of interest
#' @param colname2 Column name, as a string, of second categorical variable of interest
#'   
#' @return Jaccard similarity matrix for the two columns. `colname1` values will 
#'   be row names and `colname2` values will be column names in the final matrix
make_jaccard_matrix <- function(celltype_df, colname1, colname2){
  
  # make lists of barcodes for each category, named by the category
  id1_list <- split(celltype_df$barcodes, celltype_df[[colname1]])
  id2_list <- split(celltype_df$barcodes, celltype_df[[colname2]])
  
  # create the grid of comparisons
  cross_df <- tidyr::expand_grid(id1 = names(id1_list), id2 = names(id2_list))
  
  # calculate a single Jaccard index for each combination using split lists & ids
  jaccard_scores <- cross_df |> 
    purrr::pmap_dbl(\(id1, id2){
      jaccard(id1_list[[id1]], id2_list[[id2]])
    })
  
  # add scores to the comparison grid and convert to matrix
  jaccard_matrix <- cross_df |> 
    dplyr::mutate(jaccard = jaccard_scores) |>
    # convert to matrix
    tidyr::pivot_wider(
      names_from = "id2", 
      values_from = "jaccard"
    ) |>
    tibble::column_to_rownames(var = "id1") |>
    as.matrix()
    
    return(jaccard_matrix)
}
```


<!-- Define variables, options, and functions for plotting heatmaps --> 
```{r}
# Define color ramp for shared use in the heatmap
heatmap_col_fun <- circlize::colorRamp2(c(0, 1), colors = c("white", "darkslateblue"))

# Set heatmap padding option
ComplexHeatmap::ht_opt(TITLE_PADDING = grid::unit(0.2, "in"))


#' Draw a ComplexHeatmap
#'
#' @param heatmap A heatmap or list of heatmaps to draw
#' @param legend_side Side legend appears on, default bottom
draw_heatmap <- function(heatmap, legend_side = "bottom") {
  # Render the heatmap or list of heatmaps
  ComplexHeatmap::draw(
    heatmap, 
    heatmap_legend_side = legend_side
  )
}


#' Create a ComplexHeatmap from a matrix
#'
#' @param mat Matrix to create heatmap from.
#' @param row_title Label for row title.
#' @param column_title Label for column title.
#' @param labels_font_size Font size to use for rows and column labels.
#' @param keep_legend_name The name to use in the legend
#' @param column_names_angle Angle for column names. Default is 0.
#' @param col_fun Color function for the heatmap palette. Default is `heatmat_col_fun`.
#' 
#' @return A ComplexHeatmap object
create_single_heatmap <- function(mat,
                                  row_title, 
                                  column_title, 
                                  labels_font_size,
                                  keep_legend_name,
                                  column_names_angle = 0,
                                  col_fun = heatmap_col_fun) {
  
  heat <- ComplexHeatmap::Heatmap(
    t(mat), # transpose because matrix rows are in common & we want a vertical arrangement
    col = col_fun,
    border = TRUE, # each heatmap gets its own outline
    ## Row parameters
    cluster_rows = FALSE,
    row_title = row_title, # each heatmap gets its own title
    row_title_gp = grid::gpar(fontsize = 10), 
    row_title_side = "right",
    row_names_side = "left",
    row_names_gp = grid::gpar(fontsize = labels_font_size),
    ## Column parameters
    cluster_columns = FALSE,
    column_title = column_title,
    column_title_gp = grid::gpar(fontsize = 10), 
    column_names_side = "bottom",
    column_names_rot = column_names_angle,
    column_names_gp = grid::gpar(fontsize = labels_font_size),
    ## Legend parameters
    heatmap_legend_param = list(
      title = "Jaccard index",
      direction = "horizontal",
      legend_width = unit(1.5, "in")
    ),
    # Retain only 1 legend in the final plot      
    show_heatmap_legend = row_title == keep_legend_name,
  )
  
  return(heat)
}    
      
#' Function to plot a vertically-stacked ComplexHeatmap from a list of matrices
#'
#' @param matrix_list List of matrices to plot in a vertical layout. 
#' @param column_title Title to use for columns, shared among all heatmaps
#' @param labels_font_size Font size to use for rows and column labels.
#' @param column_names_angle Angle for column names. Default is 0.
#' @param col_fun Color function for the heatmap palette. Default is `heatmat_col_fun`.
#'
#' @return A list of ComplexHeatmap objects
create_heatmap_list <- function(matrix_list,
                              column_title, 
                              labels_font_size,
                              column_names_angle = 0,
                              col_fun = heatmap_col_fun) {
  
  
  # We only want one shared legend in the end, arbitrarily grab the first one
  keep_legend_name <- names(matrix_list)[1]

  heatmap_list <- matrix_list |> 
    purrr::imap(
      create_single_heatmap, 
      column_title, 
      labels_font_size,
      keep_legend_name,
      column_names_angle = column_names_angle,
      col_fun = col_fun
    ) |>
    # concatenate vertically into HeatmapList object
    purrr::reduce(ComplexHeatmap::`%v%`) 
  
  return(heatmap_list)
}


#' Determine the label font size based on nchar of cell type labels
#'
#' @param input_labels List of names with column names to query
#' @param is_list Boolean for whether the `input_labels` is a list, default TRUE.
#'   When this value is a list, we first need to extract its names before querying them.
#'   
#' @return Desired font size numeric
find_label_size <- function(input_labels, 
                            is_list = TRUE) {
  
  # extract colnames if we have a list
  if (is_list) {
    input_labels <- input_labels |>
      purrr::map(colnames) |> 
      unlist() 
  }
  
  longest_name <- input_labels |>
    nchar() |> 
    max()

  labels_font_size <- dplyr::case_when(
    longest_name < 35 ~ 9.5, 
    longest_name < 45 ~ 8.5, 
    longest_name < 60 ~ 7.5,
    .default = 6.5
  )
  
  return(labels_font_size)
}
```


```{r, message = FALSE, warning = FALSE, echo = FALSE}
# define library and sce object
library_id <- params$library
processed_sce <- params$processed_sce

# check for annotation methods
has_singler <- "singler" %in% metadata(processed_sce)$celltype_methods
has_cellassign <- "cellassign" %in% metadata(processed_sce)$celltype_methods
has_submitter <- "submitter" %in% metadata(processed_sce)$celltype_methods

# Create data frame of cell types
celltype_df <- create_celltype_df(processed_sce)

# what celltypes are available?
available_celltypes <- c(
  ifelse(has_submitter, "Submitter", NA),
  ifelse(has_singler, "SingleR", NA),
  ifelse(has_cellassign, "CellAssign", NA)
) |> 
  na.omit()
```


## Cell label comparison plots

This section displays heatmaps comparing cell labels from various methods. 

We use the [Jaccard index](https://en.wikipedia.org/wiki/Jaccard_index) to display the agreement between between pairs of labels from different methods.

The Jaccard index reflects the degree of overlap between the two labels and ranges from 0 to 1. 

* If the labels are assigned to identical sets of cells, the Jaccard index will be 1.
* If the labels are assigned to completely non-overlapping sets of cells, the Jaccard index will be 0.


### Comparison with unsupervised clustering

Here we show the labels from unsupervised clustering compared against cell type annotations. 
Cluster assignment was performed using the `r metadata(processed_sce)$cluster_algorithm` algorithm.


```{r}
# Calculate all jaccard matrices of interest for input to heatmap
jaccard_cluster_matrices <- available_celltypes |> 
  stringr::str_to_lower() |>
  purrr::map(\(name) {
    make_jaccard_matrix(
      celltype_df, 
      "cluster", 
      glue::glue("{name}_celltype_annotation")
    )}) |>
  purrr::set_names(available_celltypes)

# TODO: incorporate this
n_celltypes <- jaccard_cluster_matrices |>
  purrr::map(colnames) |> 
  unlist() |> 
  length()
  
# set height based on number of matrices
heatmap_height <- length(jaccard_cluster_matrices) * 2.5
```

```{r, fig.height = heatmap_height, fig.width = 8.5, warning = FALSE}
jaccard_cluster_matrices |>
  create_heatmap_list(
    column_title = "Clusters", 
    labels_font_size = find_label_size(jaccard_cluster_matrices)
  ) |>
  draw_heatmap()
```





```{r, eval = has_submitter & (has_cellassign | has_singler)}
methods_string <- dplyr::case_when(
  has_cellassign & has_singler ~ "`SingleR` and `CellAssign`",
  has_singler  ~ "`SingleR`",
  has_cellassign  ~ "`CellAssign`"
)

knitr::asis_output(
  glue::glue(
  "## Comparison with submitter annotations

  This section displays heatmaps comparing submitter-provided cell type annotations to those obtained from {methods_string}."
  )
)
```

```{r}
# don't compare submitter to submitter
available_celltypes <- available_celltypes[!(available_celltypes == "Submitter")]

# calculate matrices comparing to submitter
jaccard_submitter_matrices <- available_celltypes |> 
  stringr::str_to_lower() |>
  purrr::map(\(name) {
    make_jaccard_matrix(
      celltype_df, 
      "cluster", 
      glue::glue("{name}_celltype_annotation")
    )}) |>
  purrr::set_names(available_celltypes)

# how many unique cell types?
n_celltypes <- jaccard_submitter_matrices |>
  purrr::map(colnames) |> 
  unlist() |> 
  length()

if (has_singler) {
  jaccard_submitter_matrices[["SingleR"]] <- make_jaccard_matrix(
    celltype_df, 
    "submitter_celltype_annotation", 
    "singler_celltype_annotation"
  )
  n_celltypes <- n_celltypes + length(unique(celltype_df$singler_celltype_annotation))
}
if (has_cellassign) {
  jaccard_submitter_matrices[["CellAssign"]] <- make_jaccard_matrix(
    celltype_df, 
    "submitter_celltype_annotation", 
    "cellassign_celltype_annotation"
  )
  n_celltypes <- n_celltypes + length(unique(celltype_df$cellassign_celltype_annotation))
}

# Set plot dimensions based on number of cell types
heatmap_height <- n_celltypes / 4.5
```

```{r, fig.height = heatmap_height, fig.width = 8.5, warning = FALSE}
jaccard_submitter_matrices |>
  create_heatmap_list(
    column_title = "Submitted-provided annotations", 
    labels_font_size = find_label_size(jaccard_submitter_matrices), 
    column_names_angle = 90
  ) |>
  draw_heatmap()
```


```{r, eval = has_cellassign & has_singler, fig.height=7, fig.width=8}
knitr::asis_output("
### Comparison between `SingleR` and `CellAssign` annotations

This section displays a heatmap directly comparing `SingleR` and `CellAssign` cell type annotations.
Note that due to different annotations references, these methods may use different names for similar cell types.
")

# Set plot dimensions based on number of SingleR types
heatmap_height <- length(levels(celltype_df$singler_celltype_annotation)) / 3.5
```


```{r, eval = has_cellassign & has_singler, fig.height = heatmap_height, fig.width = 8.5}
# Calculate jaccard matrix
singler_cellassign_matrix <- make_jaccard_matrix(
  celltype_df, 
  "singler_celltype_annotation",
  "cellassign_celltype_annotation"
)

labels_font_size <- find_label_size(
  # simply provide the vector for this heatmap since its not a list
  c(
    rownames(singler_cellassign_matrix), 
    colnames(singler_cellassign_matrix)
  ), 
  is_list = FALSE
)

create_single_heatmap(
  singler_cellassign_matrix, 
  row_title = "SingleR annotations",
  column_title = "CellAssign annotations", 
  labels_font_size = labels_font_size, 
  keep_legend_name = "SingleR annotations",
  column_names_angle = 90,
  col_fun = heatmap_col_fun
  ) |>
  draw_heatmap()
```


```{r, eval = has_singler | has_cellassign }
knitr::asis_output("
## Annotation Assessment

In this section, we assess the reliability of cell type annotations using diagnostic plots.
")
```

```{r, eval = has_singler}
knitr::asis_output("
### `SingleR` assessment

To assess the quality of `SingleR` cell type annotations, we use the _delta median_ statistic.

- _Delta median_ is calculated for each cell as the difference between the `SingleR` score of the annotated cell type label and the median score of the other cell type labels in the reference dataset.
- Higher _delta median_ values indicate higher quality cell type annotations.
  - Values can range from 0-1.
  - Note that there is no universal threshold for calling absolute high vs. low quality, as described in the [`SingleR` book section on 'Annotation diagnostics'](https://bioconductor.org/books/release/SingleRBook/annotation-diagnostics.html#annotation-diagnostics).

You can interpret this plot as follows:

- Each point represents the _delta median_ statistic of a given cell whose `SingleR` annotation is shown on the y-axis.
- The point color indicates `SingleR`'s quality assessment of the annotation:
  - High-quality cell annotations are shown as closed points.
  - Low-quality cell annotations are shown as open points.
  In other sections of this report, these cells are referred to as `Unknown cell types`.
  - For more information on how `SingleR` calculates annotation quality, please refer to [this `SingleR` documentation](https://rdrr.io/bioc/SingleR/man/pruneScores.html).
- Red diamonds represent the median _delta median_ statistic among high-quality annotations for the given cell type label.
")
```


```{r, eval = has_singler, warning=FALSE, message=FALSE}
# Prepare SingleR scores for plot

# extract scores into matrix
singler_scores <- metadata(processed_sce)$singler_result$scores

# Create data frame for plotting with delta median and the full *non-pruned* cell labels
delta_median_df <- tibble::tibble(
  delta_median = rowMaxs(singler_scores) - rowMedians(singler_scores),
  # Need to grab the non-pruned label for this plot
  full_labels = metadata(processed_sce)$singler_result$labels,
  # if pruned.labels are NA ==> low confidence
  # so, negate for this variable:
  confident = !is.na(metadata(processed_sce)$singler_result$pruned.labels)
) |>
  dplyr::mutate(confident =
    ifelse(confident, "High-quality", "Low-quality")
  )

# If ontologies were used for `full_labels`, we'll need to map back to cell type names
#  for the plot itself.
if ("singler_celltype_ontology" %in% names(celltype_df)) {
  # we use inner_join b/c the above tibble does NOT contain "Unknown cell type", which
  #  we do not want to display here
  delta_median_df <- delta_median_df |>
    dplyr::inner_join(
      tibble::tibble(
        full_labels = celltype_df$singler_celltype_ontology,
        celltype = celltype_df$singler_celltype_annotation
      ) |> dplyr::distinct()
    ) |>
    dplyr::select(-full_labels)
} else {
  # otherwise, full_labels already contain what we want to plot, so just rename it
  delta_median_df <- delta_median_df |>
    dplyr::rename(celltype = full_labels)
  # still need to add levels:
  # Note that the level "Unknown cell type" will still be present, but there is no such value in the data, so it won't matter
  levels(delta_median_df$celltype) <- levels(celltype_df$singler_celltype_annotation)
}

# Ensure we have no "Unknown cell type" values left:
if (any(delta_median_df$celltype == "Unknown cell type")) {
  stop("Failed to process SingleR data for diagnostic plot.")
}

# add column with ordered levels with wrapped labels for visualization
delta_median_df$annotation_wrapped <- factor(
  delta_median_df$celltype,
  # rev() so large groups are at the TOP of the plot
  levels = rev(levels(delta_median_df$celltype)),
  labels = rev(stringr::str_wrap(levels(delta_median_df$celltype), 30))
)

# Subset the data to just confident points for median+/-IQR
delta_median_confident_df <- delta_median_df |>
  dplyr::filter(confident == "High-quality")

# Determine height for plot area based on number of cells
plot_height <- length(unique(delta_median_df$celltype))/2.5
```

```{r, eval = has_singler, warning=FALSE, message=FALSE, fig.height = plot_height, fig.width = 6.5}
# Plot delta_median across celltypes colored by pruning
ggplot(delta_median_df) +
  aes(
    x = delta_median,
    y = annotation_wrapped,
    shape = confident,
    alpha = confident
  ) +
  ggforce::geom_sina(
    size = 0.8,
    color = "black", # will get applied to all confident points and non-confident outline
    fill = "white", # will apply to non-confident fill only
    position = position_dodge(width = 0.05) # Keep both types of points mostly in line
  ) +
  # Handle points aesthetics:
  #  confident are closed black with alpha = 0.5
  #  not confident are open black with alpha = 1
  scale_shape_manual(values = c(19, 21)) +
  scale_alpha_manual(values = c(0.5, 1)) +
  labs(
    x = "Delta median statistic",
    y = "Cell type annotation",
    shape = "Cell type annotation quality"
  ) +
  # add median diamond for confident points only
  stat_summary(
    data = delta_median_confident_df,
    color = "red",
    geom = "point",
    fun = "median",
    shape = 18,
    size = 2.25,
    alpha = 0.9
  ) +
  guides(
    alpha = FALSE,
    shape = guide_legend(override.aes = list(size = 1.5, alpha = 0.55))
  ) +
  theme(
    legend.position = "bottom"
  )
```





```{r, eval = has_cellassign}
knitr::asis_output("
### `CellAssign` assessment

To assess the quality of `CellAssign` cell type annotations, we look at the probability associated with the annotated cell type. 
These probabilities are provided directly by `CellAssign`:

- `CellAssign` first calculates the probability of each cell being annotated as each cell type present in the reference.
- `CellAssign` then annotates cells by selecting the cell type with the highest probability among all cell types considered. 
- These probabilities range from 0 to 1, with larger values indicating greater confidence in a given cell type label.
We therefore expect reliable labels to have values close to 1.

The plot below shows the distribution of `CellAssign`-calculated probabilities for the final cell type labels.
Blue line segments shown as a 'rug' represent individual values that comprise each distribution.

Note that no distrubution is shown for cell types with 2 or fewer labeled cells, but rug points are shown.
Rug points are also taller for any cell type label with 5 or fewer cells.
")

# Determine height in inches for plot area
plot_height <- ceiling(length(unique(celltype_df$cellassign_celltype_annotation))/2.5)
```


```{r, eval = has_cellassign, warning=FALSE, message=FALSE, fig.height = plot_height, fig.width = 6}
# define bandwidth for all calculations
density_bw <- 0.03

# find the maximum density across all distributions, and
#  save the maximum for determining geom_segment height
y_max <- celltype_df$cellassign_max_prediction |>
  split(celltype_df$cellassign_celltype_annotation) |>
  purrr::map_dbl(
    \(x) max(density(x, bw = density_bw)$y)
  ) |> 
  max()

# add count to celltype_df for setting alpha and yend values
celltype_df <- celltype_df |>
  dplyr::add_count(cellassign_celltype_annotation)

# make the plot!
ggplot(celltype_df) + 
  aes(x = cellassign_max_prediction) + 
  geom_density(
    bw = density_bw, 
    fill = "grey65", 
    linewidth = 0.25, 
    bounds = c(0, 1)
  ) + 
  geom_segment(
    aes(
      # set alpha to vary based on the number of points in the row such that
      #  rows with more points are more transparent
      alpha = pmax(0.2, 1 - 0.01 * n),
      xend = cellassign_max_prediction,
      # set yend as either 0 for rows with many points, or y_max/2.5 for 
      #  rows with few points
      yend = ifelse(n > 5, 0, y_max/2.5),
      y = -Inf
    ),
    color = "blue"
  ) +
  labs(
    x = "Probability of annotated cell type",
    y = ""
  ) +
  coord_cartesian(xlim = c(0,1)) +
  scale_y_continuous(expand = c(0.1, 0.1)) +
  scale_alpha_identity() + 
  facet_grid(
    rows = vars(cellassign_celltype_annotation), 
    switch = "y"
  ) +
  theme(
    strip.background = element_blank(),
    strip.text.y.left = element_text(
      angle = 0, 
      hjust = 1
    ),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.minor = element_blank(), 
    panel.grid.major.y = element_blank(), 
    panel.spacing = unit(0.02, "in")
  )
```