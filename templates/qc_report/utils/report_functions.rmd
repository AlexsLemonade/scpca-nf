<!-- This document contains function definitions that are used by both
`main_qc_report.rmd` and `celltypes_supplemental_report.rmd` but are not specific to cell typing -->


```{r}
#' Determine size for UMAP points which depends on the number of cells in the
#'   processed object.
#'
#' @param n_processed_cells Number of cells in the processed object
#'
#' @return A vector with two integer values: A standalone UMAP point size, and a
#'   point size for faceted UMAPs
determine_umap_point_size <- function(n_processed_cells) {
  umap_point_size <- dplyr::case_when(
    n_processed_cells <= 500 ~ 0.8,
    n_processed_cells <= 2250 ~ 0.6,
    .default = 0.3
  )
  umap_facet_point_size <- dplyr::case_when(
    n_processed_cells <= 500 ~ 0.5,
    n_processed_cells <= 2250 ~ 0.25,
    n_processed_cells <= 5000 ~ 0.1,
    .default = 0.01
  )

  return(c(umap_point_size, umap_facet_point_size))
}

#' Make UMAP colored by clusters
#'
#' @param sce SingleCellExperiment object with UMAP embeddings
#' @param point_size Point size. Default is 1
#'
#' @return UMAP plot as a ggplot2 object
#'
plot_clusters_umap <- function(
    sce,
    point_size = 1) {
  # umap colored by clusters
  clusters_plot <- scater::plotUMAP(
    sce,
    point_size = umap_point_size,
    point_alpha = 0.5,
    colour_by = "cluster"
  ) +
    # remove axis numbers and background grid
    scale_x_continuous(labels = NULL, breaks = NULL) +
    scale_y_continuous(labels = NULL, breaks = NULL) +
    guides(
      color = guide_legend(
        title = "Cluster",
        nrow = 2,
        # more visible points in legend
        override.aes = list(
          alpha = 1,
          size = 1.5
        )
      )
    ) +
    theme_bw() +
    theme(
      legend.position = "bottom",
      aspect.ratio = 1
    )

  # Determine palette based on number of levels.
  # If we have <=8, we can use a CVD-friendly palette (they generally don't have more than 8 colors).
  #  Otherwise, we will use the default palette.
  if (length(levels(sce$cluster)) <= 8) {
    clusters_plot +
      scale_color_brewer(palette = "Set2")
  } else {
    clusters_plot
  }

  return(clusters_plot)
}
```

```{r}
#' Print table with sample metadata
#'
#' @param meta_list List of metadata from SCE object.
#'   Must contain `sample_metadata`.
#'
#' @return table with sample metadata

print_sample_metadata <- function(meta_list) {
  # get sample metadata as a data frame
  sample_metadata <- meta_list$sample_metadata

  # only print table if sample metadata is present
  if (!is.null(sample_metadata)) {
    # build urls using ontology terms
    # first create a tibble with term, human readable value, and ontology ID
    ontology_link_df <- tibble::tribble(
      ~term, ~hr_value, ~ontology_term_id,
      "age", as.character(sample_metadata$age), sample_metadata$development_stage_ontology_term_id,
      "sex", sample_metadata$sex, sample_metadata$sex_ontology_term_id,
      "organism", sample_metadata$organism, sample_metadata$organism_ontology_id,
      "diagnosis", sample_metadata$diagnosis, sample_metadata$disease_ontology_term_id,
      "tissue_location", sample_metadata$tissue_location, sample_metadata$tissue_ontology_term_id
    ) |>
      dplyr::mutate(
        # replace ID with _ to construct url
        ontology_term_id = stringr::str_replace(ontology_term_id, ":", "_"),
        # build url
        url = glue::glue("http://purl.obolibrary.org/obo/{ontology_term_id}"),
        # format linked url with hr value for table
        # if NA term ID, don't link
        url = dplyr::if_else(
          is.na(ontology_term_id),
          kableExtra::text_spec(hr_value, "html"),
          kableExtra::text_spec(hr_value, "html", link = url)
        )
      )

    # create a named list of urls to use for easy table building
    url_list <- as.list(ontology_link_df$url) |>
      purrr::set_names(ontology_link_df$term)

    # construct table to print
    # fill in with sample metadata information for non ontology IDs and use urls for all ontology IDs
    table <- tibble::tibble(
      "Sample ID" = sample_metadata$sample_id,
      "Diagnosis" = url_list$diagnosis,
      "Subdiagnosis" = sample_metadata$subdiagnosis,
      "Tissue location" = url_list$tissue_location,
      "Disease timing" = sample_metadata$disease_timing,
      "Age" = url_list$age,
      "Sex" = url_list$sex,
      "Organism" = url_list$organism,
      "Sample type" = paste0(meta_list$sample_type, collapse = ", ")
    ) |>
      t() |>
      # account for html links
      knitr::kable(format = "html", escape = FALSE, align = "r") |>
      kableExtra::kable_styling(
        bootstrap_options = "striped",
        full_width = FALSE,
        position = "left"
      ) |>
      kableExtra::column_spec(2, monospace = TRUE)

    return(table)
  } else {
    # if no sample metadata, print out a message
    knitr::asis_output(
      glue::glue("
    <div class=\"alert alert-info\">

    No sample metadata is available for this library.

    </div>
  ")
    )
  }
}
```

```{r}
#' Format DT datatables
#'
#' @param df Data frame to format
#'
#' @return DT datatable
format_datatable <- function(df) {
  df |>
    DT::datatable(
      rownames = FALSE,
      extensions = "Scroller",
      options = list(
        scroller = TRUE,
        deferRender = TRUE,
        scrollX = TRUE,
        scrollY = 400,
        scrollCollapse = TRUE,
        language = list(search = "Filter:"),
        columnDefs = list(list(
          # render missing values as "NA" rather than blanks in the table
          targets = "_all",
          render = DT::JS(
            "function(data, type, row, meta) {",
            "return data === null ? 'NA' : data;",
            "}"
          )
        ))
      )
    )
}
```


```{r}
#' Function to lump celltype columns in an existing data frame for all of the
#'  following columns, if they exist: `{type}_celltype_annotation`.
#' The cell types will also be renamed via wrapping at the given `wrap` level.
#'  The resulting lumped column will be named:
#'  `{type}>_celltype_annotation_lumped`.
#'
#'
#' @param df Data frame to manipulate
#' @param n_celltypes Number of groups to lump into, with rest put into "Other" group. Default is 7.
#' @param wrap Characters to wrap the cell type label
#'
#' @return Updated df with new column of lumped celltypes for each present method
lump_wrap_celltypes <- function(df, n_celltypes = 7, wrap = 35) {
  df <- df |>
    # First, wrap labels
    dplyr::mutate(
      across(
        ends_with("_celltype_annotation"),
        \(x) stringr::str_wrap(x, wrap)
      )
    ) |>
    # Next, apply factor lumping, but ensure final order is via frequency with the "others" at the end
    dplyr::mutate(
      across(
        ends_with("_celltype_annotation"),
        \(x) {
          x |>
            forcats::fct_lump_n(n_celltypes, other_level = "All remaining cell types", ties.method = "first") |>
            forcats::fct_infreq() |>
            forcats::fct_relevel("Unknown cell type", "All remaining cell types", after = Inf)
        },
        .names = "{.col}_lumped"
      )
    )
  return(df)
}
```
