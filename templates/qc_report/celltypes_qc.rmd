# Cell type Annotation Summary

```{r}
## function definitions ##

# Source functions for preparing cell type data
source(file.path("utils", "celltype_functions.R"))

#' Create tables of cell type annotation counts
#'
#' @param df Data frame with cell types
#' @param celltype_column Column with cell type annotations, not a string.
#'
#' @return table with cell type counts
create_celltype_n_table <- function(df, celltype_column) {
  df |>
    dplyr::count({{ celltype_column }}) |>
    # Add percentage column
    dplyr::mutate(
      `Percent of cells` = paste0(round(n / sum(n) * 100, digits = 2), "%")
    ) |>
    # set column order & rename
    dplyr::select(
      `Annotated cell type` = {{ celltype_column }},
      `Number of cells` = n,
      `Percent of cells`
    )
}

#' Format tables of cell type counts as kable
#'
#' @param df Data frame to format
#'
#' @return kable table of cell type counts
format_celltype_n_table <- function(df) {
  df |>
    knitr::kable(align = "r") |>
    kableExtra::kable_styling(
      bootstrap_options = "striped",
      full_width = FALSE,
      position = "left"
    ) |>
    kableExtra::column_spec(2, monospace = TRUE)
}

#' Function to lump celltype columns in an existing data frame for all of the
#'  following columns, if they exist: `<singler/cellassign/submitter>_celltype_annotation`.
#'  The resulting lumped column will be named:
#'  `<singler/cellassign/submitter>_celltype_annotation_lumped`.
#'
#'
#' @param df Data frame to manipulate
#' @param n_celltypes Number of groups to lump into, with rest put into "Other" group. Default is 7.
#'
#' @return Updated df with new column of lumped celltypes for each present method
lump_celltypes <- function(df, n_celltypes = 7) {

  # Update the df for each of the following, if present
  methods <- c("singler", "cellassign", "submitter")
  df <- df |>
    dplyr::mutate(
      across(
        ends_with("_celltype_annotation"),
        \(x) forcats::fct_lump_n(x, n_celltypes, other_level = "Other cell type"),
        .names = "{.col}_lumped"
      )
    )

  return(df)
}





#' Make UMAP  colored by given variable
#'
#' @param umap_df Data frame with UMAP1 and UMAP2 columns
#' @param color_variable Column in data frame to color by, not a string.
#' @param legend_title Title for legend.
#' @param legend_nrow Number of rows in legend. Default is 2.
#'
#' @return UMAP plot as a ggplot2 object
plot_umap <- function(
  umap_df,
  color_variable,
  legend_title,
  legend_nrow = 2
){
  ggplot(umap_df) +
    aes(
      x = UMAP1,
      y = UMAP2,
      color = {{ color_variable }}
    ) +
    geom_point(
      size = 0.3,
      alpha = 0.5
    ) +
    # remove axis numbers and background grid
    scale_x_continuous(labels = NULL, breaks = NULL) +
    scale_y_continuous(labels = NULL, breaks = NULL) +
    coord_fixed() +
    guides(
      color = guide_legend(
        title = legend_title,
        nrow = legend_nrow,
        # more visible points in legend
        override.aes = list(
          alpha = 1,
          size = 1.5
        )
      )
    ) +
    theme(legend.position = "bottom")
}
```


<!-- Background depends on which cell types are present in the SCE. -->


<!-- Submitter _only_ -->
```{r, eval = has_submitter & !(has_singler | has_cellassign)}
knitr::asis_output(
  glue::glue("
  This section details cell type annotations provided by the original lab (`submitter-provided`) which generated this data.
  ")
)
```


<!-- At least one cell type annotation method. -->
```{r, eval = has_singler | has_cellassign}
knitr::asis_output(
  glue::glue("
  This section details results from performing cell type annotation.
  The following method(s) were used to perform cell typing:
 ")
)
```


```{r, eval = has_singler}
knitr::asis_output(
  glue::glue(
  "* [`SingleR`](https://bioconductor.org/packages/release/bioc/html/SingleR.html), which uses a reference-based approach.
  The `{metadata(processed_sce)$singler_reference}` reference dataset, obtained from the [`celldex` package](http://bioconductor.org/packages/release/data/experiment/html/celldex.html) package, was used for cell typing."
  )
)
```


```{r, eval = has_cellassign}
knitr::asis_output(
  glue::glue(
  "* [`CellAssign`](https://github.com/Irrationone/cellassign), which uses a marker-gene based approach.
  Marker genes associated with `{metadata(processed_sce)$cellassign_reference}` tissue were obtained from [PanglaoDB](https://panglaodb.se/).
  "
  )
)
```


<!-- Submitter and at least one inference method -->
```{r, eval = has_submitter & (has_singler | has_cellassign)}
knitr::asis_output(
  glue::glue(
  "* Cell type annotations were also provided by the original lab (`submitter-provided`) which generated this data.
  "
  )
)
```

For additional information about cell typing, including diagnostic plots and/or heatmap comparisons among annotations (if available), please refer to the [supplementary cell type QC report](`r params$celltype_report`).


## Statistics

```{r}
# Create data frame of cell types
celltype_df <- create_celltype_df(processed_sce)
```


```{r, eval = has_submitter}
knitr::asis_output('
### Submitter-provided cell type annotations\n

In this table, cells labeled "Unclassified cell" are those for which submitters did not provide an annotation.
')
create_celltype_n_table(celltype_df, submitter_celltype_annotation) |>
  format_celltype_n_table()
```

```{r, eval = has_singler}
knitr::asis_output('### `SingleR` cell type annotations\n

In this table, cells labeled as "Unknown cell type" are those which `SingleR` could not confidently identify.
')
create_celltype_n_table(celltype_df, singler_celltype_annotation) |>
  format_celltype_n_table()
```

```{r, eval = has_cellassign}
knitr::asis_output('### `CellAssign` cell type annotations\n

In this table, cells labeled as "Unknown cell type" are those which `CellAssign` could not confidently identify.
')
create_celltype_n_table(celltype_df, cellassign_celltype_annotation) |>
  format_celltype_n_table()
```

## UMAPs

In this section, we show UMAPs colored by clusters and cell types.
A separate UMAP is shown for each cell typing method used.
Clusters were calculated using the graph-based `r metadata(processed_sce)$cluster_algorithm` algorithm with `r metadata(processed_sce)$cluster_weighting` weights.

For legibility, only the seven most common cell types are shown.
All other cell types are grouped together and labeled "Other cell type" (not to be confused with "Unknown cell types," which represent cells that could not be classified).


```{r}
# Create dataset for plotting UMAPs with lumped cell types
umap_df <- lump_celltypes(celltype_df)
```


<!-- First UMAP: clusters -->
```{r message=FALSE, warning=FALSE}
clusters_plot <- plot_umap(
  umap_df,
  cluster,
  "Clusters"
) +
  ggtitle("UMAP colored by clusters")

# Determine palette based on number of levels.
# If we have <=8, we can use a CVD-friendly palette (they generally don't have more than 8 colors).
#  Otherwise, we will use the default palette.
if (length(levels(umap_df$cluster)) <= 8) {
  clusters_plot +
    scale_color_brewer(palette = "Set2")
} else {
  clusters_plot
}
```

<!-- Now, UMAPs of cell types, where present -->

```{r eval = has_submitter, message=FALSE, warning=FALSE}
plot_umap(umap_df,
  submitter_celltype_annotation_lumped,
  "Cell types",
  legend_nrow = 4
) +
  ggtitle("UMAP colored by submitter-provided annotations") +
  scale_color_brewer(palette = "Dark2")
```


```{r eval=has_singler, message=FALSE, warning=FALSE}
plot_umap(umap_df,
  singler_celltype_annotation_lumped,
  "Cell types",
  legend_nrow = 4
) +
  ggtitle("UMAP colored by SingleR annotations") +
  scale_color_brewer(palette = "Dark2")
```


```{r, eval = has_cellassign, message=FALSE, warning=FALSE}
plot_umap(umap_df,
  cellassign_celltype_annotation_lumped,
  "Cell types",
  legend_nrow = 4
) +
  ggtitle("UMAP colored by CellAssign annotations") +
  scale_color_brewer(palette = "Dark2")
```
