---
params:
  library: Example
  processed_sce: NULL
  validation_groups_df: NULL
  validation_markers_df: NULL
  validation_palette_df: NULL
  date: !r Sys.Date()
title: "`r glue::glue('ScPCA Supplemental cell type report for {params$library}')`"
author: "Childhood Cancer Data Lab"
date: "`r params$date`"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
    number_sections: false
    code_download: true
---

<!--Make sure tabs always fit on one line--> 
<style>
  .nav-tabs {
    display: flex !important;
    flex-wrap: nowrap !important;
    flex: 1 1 auto !important;
    text-align: center;
    white-space: normal !important;
  }
</style>

```{r, echo=FALSE, results='asis'}
# Include dark mode toggle component
dark_mode_path <- file.path(dirname(getwd()), "templates", "dark-mode-toggle.html")
if (!file.exists(dark_mode_path)) {
  # Try alternative path if running from different directory
  dark_mode_path <- file.path("templates", "dark-mode-toggle.html")
}
if (!file.exists(dark_mode_path)) {
  # Try current directory path
  dark_mode_path <- "dark-mode-toggle.html"
}
if (file.exists(dark_mode_path)) {
  cat(readLines(dark_mode_path), sep = "\n")
}
```

```{r setup, message = FALSE, echo = FALSE}
# knitr options
knitr::opts_chunk$set(
  echo = FALSE
)

library(SingleCellExperiment)
library(ggplot2)
library(patchwork)

# Set default ggplot theme
theme_set(
  theme_bw() +
    theme(
      plot.margin = margin(rep(20, 4)),
      strip.background = element_rect(fill = "transparent")
    )
)

# This _is_ the supplemental report
# we should not print the chunk from celltypes_qc.rmd recapitulating bullets
#  and pointing users to this supp report
is_supplemental <- TRUE
```

<!-- Import shared functions for cell type wrangling -->
```{r, child='utils/celltype_functions.rmd'}
```
```{r, child='utils/report_functions.rmd'}
```


```{r, message = FALSE, warning = FALSE, echo = FALSE}
# define library and sce object
library_id <- params$library
processed_sce <- params$processed_sce

# check for annotation methods
has_singler <- "singler" %in% metadata(processed_sce)$celltype_methods
has_cellassign <- "cellassign" %in% metadata(processed_sce)$celltype_methods
has_consensus <- "consensus_celltype_annotation" %in% names(colData(processed_sce))
has_submitter <- "submitter" %in% metadata(processed_sce)$celltype_methods &&
  !all(is.na(processed_sce$submitter_celltype_annotation)) # make sure they aren't all NA

# If at least 1 is present, we have cell type annotations.
has_celltypes <- any(has_singler, has_cellassign, has_consensus, has_submitter)

# check for umap and clusters
has_umap <- "UMAP" %in% reducedDimNames(processed_sce)
has_clusters <- "cluster" %in% names(colData(processed_sce))

# what celltypes are available?
available_celltypes <- c(
  ifelse(has_submitter, "Submitter", NA),
  ifelse(has_singler, "SingleR", NA),
  ifelse(has_cellassign, "CellAssign", NA),
  ifelse(has_consensus, "Consensus", NA)
) |>
  na.omit() |>
  as.character()

# was cellassign run?
cellassign_not_run <- check_cellassign_not_run(
  has_cellassign,
  colData(processed_sce)
)


# check for validation group info if consensus cell types are present
if (has_consensus) {
  stopifnot(
    "Consensus cell types are present but the validation_groups_df has not been provided" = !is.null(params$validation_groups_df),
    "Consensus cell types are present but the validation_markers_df has not been provided" = !is.null(params$validation_markers_df),
    "Consensus cell types are present but the validation_palette_df has not been provided" = !is.null(params$validation_palette_df)
  )
}

# This variable need to be defined for edge conditions when certain cell types
#  aren't available:
#  When we have chunks with `eval=<has_method>`, knitr seems to need all other
#  variables used in chunk params defined, including plot dimension variables
#  which would have only been created in chunks which also had an associated
#  eval=<has_method>`. Since those chunks won't have been eval'd if FALSE, we
#  need to define this variable to prevent errors, but this value will never
#  actually be used.
plot_height <- 1

# Determine if library is multiplexed:
#  sample_id should be defined with length > 1
sample_id <- metadata(processed_sce)$sample_id
has_multiplex <- length(sample_id) > 1
```

<!-- If multiplexed, open with warning  --> 
```{r, eval = has_multiplex, results='asis'}
# convert sample id to bullet separated list
multiplex_samples <- paste0("<li>", paste(sample_id, collapse = "</li><li>", "</li>"))
glue::glue("
 <div class=\"alert alert-warning\">

 This library is multiplexed and contains data from more than one sample.
 Data from the following samples are included in this library:

    {multiplex_samples}

  </div>
")
```

This report contains a summary of cell type annotation results for library `r library_id`.
The goal of this report is to provide more detailed information about cell type annotation results as an initial evaluation of their quality and reliability.

Performing cell type annotation is an inherently challenging task with high levels of uncertainty, especially when using automated annotation methods.
One way to address this is to use multiple cell type annotation approaches and compare the results, as we have begun to do in this report.

When multiple methods annotate a given cell as the same or similar cell type, this may qualitatively indicate a more robust annotation.

Note that the contents of this report will vary based on which cell type annotations are present.
Further, be aware that different cell type annotation methods may assign different labels to the same or similar cell type (e.g., the different string representations `B cell naive` and `Naive B cell`), due to use of different underlying reference datasets.
Please note that all cell type annotation reference datasets are derived from normal (not tumor) tissue.

<!--Note that the specific contents of this report will depend on which cell type annotations are present.-->
**This library contains the following cell type annotations:**

```{r results='asis'}
# build up this string as we go:
methods_text <- ""

if (has_submitter) {
  methods_text <- glue::glue(
    "{methods_text}
    * Submitter-provided cell type annotation, generated by the original lab which produced this data.\n"
  )
}

if (has_singler) {
  methods_text <- glue::glue(
    "{methods_text}
    * Annotations from [`SingleR`](https://bioconductor.org/packages/release/bioc/html/SingleR.html), a reference-based approach ([Looney _et al._ 2019](https://doi.org/10.1038/s41590-018-0276-y)).
    The `{metadata(processed_sce)$singler_reference}` dataset, obtained from the [`celldex` package](http://bioconductor.org/packages/release/data/experiment/html/celldex.html), was used for reference annotations.\n"
  )
}

if (has_cellassign) {
  organs <- metadata(processed_sce)$cellassign_reference_organs |>
    stringr::str_to_lower()
  # split up and add an `and` before the final organ
  organs_string <- stringr::str_split_1(organs, pattern = ", ") |>
    stringr::str_flatten_comma(last = ", and ")

  ref_name <- metadata(processed_sce)$cellassign_reference

  methods_text <- glue::glue(
    "{methods_text}
    * Annotations from [`CellAssign`](https://github.com/Irrationone/cellassign), a marker-gene-based approach ([Zhang _et al._ 2019](https://doi.org/10.1038/s41592-019-0529-1)).
    Marker genes for cell types were obtained from [PanglaoDB](https://panglaodb.se/) and compiled into a reference named `{ref_name}`.
    This reference includes the following organs and tissue compartments: {organs_string}.\n"
  )
}

if (has_consensus) {
  methods_text <- glue::glue(
    "{methods_text}
    * Consensus cell types based on agreement between `SingleR` and `CellAssign` using an ontology-aware approach.
    If no common label is identified, no consensus cell type is assigned.
    See the [ScPCA Portal documentation](https://scpca.readthedocs.io/en/stable/processing_information.html#cell-type-annotation) for a full description on how these cell type annotations are assigned.\n"
  )
}

glue::glue("{methods_text}")
```

```{r eval=cellassign_not_run, results='asis'}
glue::glue("
   <div class=\"alert alert-info\">
   Cell type annotation with [`CellAssign`](https://github.com/Irrationone/cellassign), a marker-gene-based approach ([Zhang _et al._ 2019](https://doi.org/10.1038/s41592-019-0529-1)), was attempted but not run due to an insufficient number of cells.
  </div>
")
```


# Sample metadata 

The below table summarizes clinical metadata for the sample associated with this library. 
Blue hyperlinks are present for any terms with an ontology term identifier associated with the displayed human readable value. 
These links will direct you to a web page with information about that ontology term identifier.   

```{r}
# extract sce metadata containing processing information as table
processed_meta <- metadata(processed_sce)

# if data is not multiplexed, print out sample metadata
if (!has_multiplex) {
  print_sample_metadata(processed_meta)
} else {
  # otherwise print out an info box that no sample metadata will be displayed
  knitr::asis_output(
    glue::glue("
      <div class=\"alert alert-info\">

      This library is multiplexed and contains data from more than one sample.
      Demultiplexing has not been performed, so sample metadata will not be displayed.
      </div>
    ")
  )
}
```


<!------- Call the celltypes_qc report section from the main report ----------->
```{r, child='celltypes_qc.rmd'}
```

<!-------------------------- Submitter heatmaps ------------------------------->
```{r, eval = submitter_heatmaps}
# don't compare submitter to submitter
automated_celltypes_available <- available_celltypes[!(available_celltypes == "Submitter")]

knitr::asis_output(
  "## Submitter-provided annotations

  This section displays heatmaps comparing submitter-provided cell type annotations to those obtained from automated cell type annotation methods, including consensus cell types, if present."
)
```

```{r, eval = submitter_heatmaps}
# calculate matrices comparing to submitter
jaccard_submitter_matrices <- automated_celltypes_available |>
  stringr::str_to_lower() |>
  purrr::map(\(name) {
    make_jaccard_matrix(
      celltype_df,
      "submitter_celltype_annotation",
      glue::glue("{name}_celltype_annotation")
    )
  }) |>
  purrr::set_names(automated_celltypes_available)

# how many cell types?
all_celltypes <- jaccard_submitter_matrices |>
  purrr::map(colnames) |>
  unlist()

plot_height <- calculate_plot_height(
  all_celltypes,
  unique(celltype_df$submitter_celltype_annotation),
  length(jaccard_submitter_matrices) - 1
)
```

```{r, eval = submitter_heatmaps, fig.height = plot_height, fig.width = 8.5, warning = FALSE}
jaccard_submitter_matrices |>
  create_heatmap_list(
    column_title = "Submitter-provided annotations",
    labels_font_size = find_label_size(all_celltypes),
    # additional arguments
    column_names_rot = 90
  ) |>
  ComplexHeatmap::draw(
    heatmap_legend_side = "bottom"
  )
```


<!---------------------- consensus cell type heatmap  -------------------------->
<!--TODO: Update with SCimilarity as additional panel --> 
```{r, eval = has_consensus, fig.height=7, fig.width=8}
knitr::asis_output("
## Automated annotations

This section displays a heatmap directly comparing cell type annotations from individual cell type annotation methods to the assigned consensus cell type label.
Note that due to different annotations references, these methods may use different names for similar cell types.
")
```

```{r, eval = has_consensus}
# having consensus celltypes implies that both SingleR and CellAssign exist
# TODO: Update to handle adding in SCimilarity
automated_celltypes <- c("SingleR", "CellAssign")

# calculate matrices comparing to consensus
jaccard_consensus_matrices <- automated_celltypes |>
  stringr::str_to_lower() |>
  purrr::map(\(name) {
    make_jaccard_matrix(
      celltype_df,
      "consensus_celltype_annotation",
      glue::glue("{name}_celltype_annotation")
    )
  }) |>
  purrr::set_names(automated_celltypes)

# how many cell types?
all_celltypes <- jaccard_consensus_matrices |>
  purrr::map(colnames) |>
  unlist()

plot_height <- calculate_plot_height(
  all_celltypes,
  unique(celltype_df$consensus_celltype_annotation),
  length(jaccard_consensus_matrices) - 1
)
```

```{r, eval = has_consensus, fig.height = plot_height, fig.width = 8.5, warning = FALSE}
jaccard_consensus_matrices |>
  create_heatmap_list(
    column_title = "Consensus cell types",
    labels_font_size = find_label_size(all_celltypes),
    # additional arguments
    column_names_rot = 90
  ) |>
  ComplexHeatmap::draw(
    heatmap_legend_side = "bottom"
  )
```

<!--TODO: Fill out clustering section -->

```{r, eval = has_umap && has_clusters}
knitr::asis_output(glue::glue("
# Unsupervised clustering

In this section, we look at unsupervised cluster assignments.
The first plot shows the cluster assignments on a UMAP and the second plot shows a heatmap comparing cluster assignments to cell type annotations.
The heatmap is colored by the Jaccard similarity index as described in the `Cell label comparisons` section above.

Clusters were calculated using the graph-based {metadata(processed_sce)$cluster_algorithm} algorithm with  {metadata(processed_sce)$cluster_weighting} weighting and {metadata(processed_sce)$cluster_nn} nearest neighbors.

**Caution**: Clusters are computed without performing any evaluation or optimization of clustering parameters.
These results should be interpreted with caution.
"))
```


```{r, eval = has_umap, warning = FALSE}
# Create dataset for plotting UMAPs with lumped and label-wrapped cell types
umap_df <- lump_wrap_celltypes(celltype_df)
```


<!-- First UMAP: clusters -->

```{r, eval = has_umap && has_multiplex && has_clusters, results='asis'}
glue::glue("
  <div class=\"alert alert-info\">
    This library contains multiple samples that have not been demultiplexed, which may confound clustering assignments.
    Please use caution when interpreting these results.
  </div>
")
```


```{r eval = has_umap && has_clusters, message=FALSE, warning=FALSE}
# create UMAP colored by clusters
plot_clusters_umap(
  processed_sce,
  umap_point_size
)
```

<!-- If multiplexed, show info alert instead of this heatmap --> 
```{r, eval = has_multiplex, results='asis'}
glue::glue("
 <div class=\"alert alert-info\">

  No heatmap comparing cluster and cell type annotation labels is shown because the presence of multiple samples may confound cluster assignment.

  </div>
")
```

<!-- If not multiplexed, show the header, text, and heatmap --> 
```{r, eval = !has_multiplex && has_clusters, results='asis'}
# Calculate all jaccard matrices of interest for input to heatmap
jaccard_cluster_matrices <- available_celltypes |>
  stringr::str_to_lower() |>
  purrr::set_names(available_celltypes) |>
  purrr::map(\(name) {
    make_jaccard_matrix(
      celltype_df,
      "cluster",
      glue::glue("{name}_celltype_annotation")
    )
  })

all_celltypes <- jaccard_cluster_matrices |>
  purrr::map(colnames) |>
  unlist()

plot_height <- calculate_plot_height(
  all_celltypes,
  unique(celltype_df$cluster),
  length(jaccard_cluster_matrices) - 1
)
```


```{r, eval = !has_multiplex && has_clusters, fig.height = plot_height, fig.width = 8.5, warning = FALSE}
jaccard_cluster_matrices |>
  create_heatmap_list(
    column_title = "Clusters",
    labels_font_size = find_label_size(all_celltypes),
    ## additional arguments
    column_names_rot = 0
  ) |>
  ComplexHeatmap::draw(
    heatmap_legend_side = "bottom"
  )
```


<!---------------------------- Diagnostic plots  ------------------------------>
```{r, eval = has_singler | has_cellassign }
knitr::asis_output("
# Quality assessments of automated annotations
")
```


<!------------------------ SingleR delta median  ------------------------------>
```{r, eval = has_singler}
knitr::asis_output("
## `SingleR` annotations

To assess the quality of `SingleR` cell type annotations, we use the delta median statistic.

- Delta median is calculated for each cell as the difference between the `SingleR` score of the annotated cell type label and the median score of the other cell type labels in the reference dataset.
- Higher delta median values indicate higher quality cell type annotations.
  - Values can range from 0-1.
  - Note that there is no universal threshold for calling absolute high vs. low quality, as described in the [`SingleR` book section on 'Annotation diagnostics'](https://bioconductor.org/books/release/SingleRBook/annotation-diagnostics.html#annotation-diagnostics).

You can interpret this plot as follows:

- Each point represents the delta median statistic of a given cell whose `SingleR` annotation is shown on the y-axis.
- The point style indicates `SingleR`'s quality assessment of the annotation:
  - High-quality cell annotations are shown as closed points.
  - Low-quality cell annotations are shown as open points.
  In other sections of this report, these cells are labeled as `Unknown cell types`.
  - For more information on how `SingleR` calculates annotation quality, please refer to [this `SingleR` documentation](https://rdrr.io/bioc/SingleR/man/pruneScores.html).
- Diamonds represent the median of the delta median statistic specifically among high-quality annotations for the given cell type annotation.
")
```


```{r, eval = has_singler, warning=FALSE, message=FALSE}
# Prepare SingleR scores for plot

# extract scores into matrix
singler_scores <- metadata(processed_sce)$singler_result$scores

# Create data frame for plotting with delta median and the full *non-pruned* cell labels
delta_median_df <- tibble::tibble(
  delta_median = rowMaxs(singler_scores) - rowMedians(singler_scores),
  # Need to grab the non-pruned label for this plot
  full_labels = metadata(processed_sce)$singler_result$labels,
  # if pruned.labels are NA ==> low confidence
  # so, negate for this variable:
  confident = !is.na(metadata(processed_sce)$singler_result$pruned.labels)
) |>
  dplyr::mutate(
    confident = ifelse(confident, "High-quality", "Low-quality")
  )

# If ontologies were used for `full_labels`, we'll need to map back to cell type names
#  for the plot itself.
if ("singler_celltype_ontology" %in% names(celltype_df)) {
  # we use inner_join b/c the above tibble does NOT contain "Unknown cell type", which
  #  we do not want to display here
  delta_median_df <- delta_median_df |>
    dplyr::inner_join(
      tibble::tibble(
        full_labels = celltype_df$singler_celltype_ontology,
        celltype = celltype_df$singler_celltype_annotation
      ) |> dplyr::distinct()
    ) |>
    dplyr::select(-full_labels)
} else {
  # otherwise, full_labels already contain what we want to plot, so just rename it
  delta_median_df <- delta_median_df |>
    dplyr::rename(celltype = full_labels)
  # still need to add levels:
  # Note that the level "Unknown cell type" will still be present, but there is no such value in the data, so it won't matter
  levels(delta_median_df$celltype) <- levels(celltype_df$singler_celltype_annotation)
}

# Ensure we have no "Unknown cell type" values left:
if (any(delta_median_df$celltype == "Unknown cell type")) {
  stop("Failed to process SingleR data for diagnostic plot.")
}

# add column with ordered levels with wrapped labels for visualization
delta_median_df$annotation_wrapped <- factor(
  delta_median_df$celltype,
  # rev() so large groups are at the TOP of the plot
  levels = rev(levels(delta_median_df$celltype)),
  labels = rev(stringr::str_wrap(levels(delta_median_df$celltype), 30))
)

# Subset the data to just confident points for median+/-IQR
delta_median_confident_df <- delta_median_df |>
  dplyr::filter(confident == "High-quality")

# Determine height for plot area based on number of cells
plot_height <- length(unique(delta_median_df$celltype)) / 2.5
```

```{r, eval = has_singler, warning=FALSE, message=FALSE, fig.height = plot_height, fig.width = 8}
# Plot delta_median across celltypes colored by pruning
ggplot(delta_median_df) +
  aes(
    x = delta_median,
    y = annotation_wrapped,
    shape = confident,
    alpha = confident
  ) +
  ggforce::geom_sina(
    size = 0.8,
    color = "black", # will get applied to all confident points and non-confident outline
    fill = "white", # will apply to non-confident fill only
    position = position_dodge(width = 0.05) # Keep both types of points mostly in line
  ) +
  # Handle points aesthetics:
  #  confident are closed black with alpha = 0.5
  #  not confident are open black with alpha = 1
  scale_shape_manual(values = c(19, 21)) +
  scale_alpha_manual(values = c(0.5, 1)) +
  labs(
    x = "Delta median statistic",
    y = "Cell type annotation",
    shape = "Cell type annotation quality"
  ) +
  # add median diamond for confident points only
  stat_summary(
    data = delta_median_confident_df,
    color = "red",
    geom = "point",
    fun = "median",
    shape = 18,
    size = 2.25,
    alpha = 0.9
  ) +
  guides(
    alpha = FALSE,
    shape = guide_legend(override.aes = list(size = 1.5, alpha = 0.55))
  ) +
  theme(
    legend.position = "bottom"
  )
```


<!---------------------- CellAssign probability plot  ------------------------->
```{r, eval = has_cellassign}
knitr::asis_output("
## `CellAssign` annotations

To assess the quality of `CellAssign` cell type annotations, we consider the probability associated with the annotated cell type.
These probabilities are provided directly by `CellAssign`:

- `CellAssign` first calculates the probability of each cell being annotated as each cell type present in the reference.
- `CellAssign` then annotates cells by selecting the cell type with the highest probability among all cell types considered.
- These probabilities range from 0 to 1, with larger values indicating greater confidence in a given cell type label.
We therefore expect reliable labels to have values close to 1.

The plot below shows the distribution of `CellAssign`-calculated probabilities for the final cell type labels.
Line segments represent individual values that comprise each distribution.

For cell types with 2 or fewer labeled cells, only the individual value line segments are shown.
Line segments are also taller for any cell type label with 5 or fewer cells.
")

# Determine height in inches for plot area
plot_height <- ceiling(length(unique(celltype_df$cellassign_celltype_annotation)) / 2.5)
```


```{r, eval = has_cellassign, warning=FALSE, message=FALSE, fig.height = plot_height, fig.width = 8}
# define bandwidth for all calculations
density_bw <- 0.03

# find the maximum density across all distributions, and
#  save the maximum for determining geom_segment height
y_max <- celltype_df$cellassign_max_prediction |>
  split(celltype_df$cellassign_celltype_annotation) |>
  # make sure we get rid of any small groups
  purrr::discard(\(x) sum(is.finite(x)) <= 2) |>
  # remove any NA's that may have slipped in
  purrr::map_dbl(
    \(x) max(density(x, bw = density_bw, na.rm = TRUE)$y)
  ) |>
  max(na.rm = TRUE)

# add count to celltype_df for setting alpha and yend values
celltype_df <- celltype_df |>
  dplyr::add_count(cellassign_celltype_annotation)

# make the plot!
ggplot(celltype_df) +
  aes(x = cellassign_max_prediction) +
  geom_density(
    bw = density_bw,
    fill = "grey65",
    linewidth = 0.25,
    bounds = c(0, 1)
  ) +
  geom_segment(
    aes(
      # set alpha to vary based on the number of points in the row such that
      #  rows with more points are more transparent
      alpha = pmax(0.2, 1 - 0.01 * n),
      xend = cellassign_max_prediction,
      # set yend as either 0 for rows with many points, or y_max/2.5 for
      #  rows with few points
      yend = ifelse(n > 5, 0, y_max / 2.5),
      y = -Inf
    ),
    color = "blue"
  ) +
  labs(
    x = "Probability of annotated cell type",
    y = "Cell type annotation"
  ) +
  scale_x_continuous(limits = c(0, 1)) +
  scale_y_continuous(expand = c(0.1, 0.1)) +
  scale_alpha_identity() +
  facet_grid(
    rows = vars(cellassign_celltype_annotation),
    switch = "y"
  ) +
  theme(
    strip.background = element_blank(),
    strip.text.y.left = element_text(
      angle = 0,
      hjust = 1
    ),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.spacing = unit(0.02, "in")
  )
```


# Session Info
<details>
<summary>R session information</summary>
```{r session_info}
if (requireNamespace("sessioninfo", quietly = TRUE)) {
  sessioninfo::session_info()
} else {
  sessionInfo()
}
```
</details>
