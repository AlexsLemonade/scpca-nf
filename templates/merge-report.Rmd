---
params:
  merge_group: "example_group"
  merged_sce: NULL
  batch_column: "library_id"
  has_adt: FALSE
  is_multiplexed: FALSE

title: "`r glue::glue('ScPCA merged report for {params$merge_group}')`"
author: "Childhood Cancer Data Lab"
date: "`r params$date`"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
    number_sections: false
    code_download: true
---

```{r setup, message = FALSE, echo = FALSE}
# knitr options
knitr::opts_chunk$set(
  echo = FALSE
)

library(SingleCellExperiment)
library(ggplot2)

# Set default ggplot theme
theme_set(
  theme_bw() +
    theme(plot.margin = margin(rep(20, 4)))
)
```

```{r}
# check that input files are provided
if (is.null(params$merged_sce)) {
  stop("Must provide a merged SCE object.")
}

# define batch column
batch_column <- params$batch_column

# set adt/ multiplex values
has_adt <- params$has_adt
is_multiplexed <- params$is_multiplexed
```

```{r, integration-warning, eval=FALSE}
glue::glue("
    <div class=\"alert alert-warning\">

    <b>CAUTION: The libraries included in the merged object are NOT integrated or batch-corrected.</b>

    </div>
  ")
```

```{r, ref.label=c('integration-warning'), eval=TRUE, results='asis'}
```


This report includes a brief summary of all libraries included in the merged object for `r params$merge_group`.
This merged object is intended to facilitate downstream analyses across multiple samples.

The libraries included in the merged object are _NOT integrated or batch-corrected_.
To conduct any downstream analyses that require batch correction (e.g., UMAP or clustering), batch correction must be performed separately. 

## Library statistics 

```{r}
# extract coldata as data frame to use to create tables
coldata_df <- colData(merged_sce) |>
  as.data.frame()

num_libraries <- merged_sce$library_id |>
  unique() |>
  length()
```

The merged object summarized in this report is comprised of `r num_libraries` individual libraries.
The following table shows a summary of the types of libraries represented.


- `Technology version` indicates which 10X Genomics kit was used for library preparation.
- `Experimental factor ontology` indicates the associated Experimental factor ontology (EFO) for the specified 10X version. 
- `Cell or Nucleus` indicates if the library was prepared using a single-cell(`cell`) or single-nuclei(`nucleus`) suspension. 


```{r}
tech_table <- coldata_df |>
  dplyr::select(library_id, tech_version, assay_ontology_term_id, seq_unit) |>
  dplyr::distinct() |>
  dplyr::count(tech_version, assay_ontology_term_id, seq_unit) |>
  dplyr::arrange(desc(n)) |>
  dplyr::rename(
    "Technology version" = "tech_version",
    "Experimental factor ontology" = "assay_ontology_term_id",
    "Cell or Nucleus" = "seq_unit",
    "Number of libraries" = "n"
  )

knitr::kable(tech_table, align = "r") |>
  kableExtra::kable_styling(
    bootstrap_options = "striped",
    full_width = FALSE,
    position = "left"
  ) |>
  kableExtra::column_spec(2, monospace = TRUE)
```

```{r, eval=has_adt}
# TODO: create a table of number of libraries with CITE-seq and without
```

```{r, eval=is_multiplexed}
# TODO: create a table of number of libraries with multiplexing and without
```


## Sample statistics

```{r}
if (is_multiplexed) {
  glue::glue("
    <div class=\"alert alert-primary\">

    The libraries included in the merged object are multiplexed.
    No demultiplexing has been done, so no sample statistics will be displayed.

    </div>
  ")
}
```


```{r, eval=!is_multiplexed}
# get total number of samples and libraries
num_samples <- merged_sce$sample_id |>
  unique() |>
  length()
```


```{r, eval=!is_multiplexed, results='asis'}
glue::glue(
  "
  The merged object summarized in this report contains {num_samples} samples.
  "
)
```

### Diagnoses

Below is a table showing the total number of samples associated with each diagnoses. 
If subdiagnosis is available, the total number of samples will be obtained for each unique combination of diagnosis and subdiagnosis. 

```{r, eval=!is_multiplexed}
# table of diagnosis
diagnosis_table <- coldata_df |>
  dplyr::select(sample_id, diagnosis, subdiagnosis) |>
  dplyr::distinct()

# if subdiagnosis is present, summarize both
if (!all(is.na(diagnosis_table$Subdiagnosis))) {
  diagnosis_table <- diagnosis_table |>
    dplyr::count(diagnosis, subdiagnosis) |>
    dplyr::arrange(desc(n)) |>
    dplyr::rename(
      "Diagnosis" = "diagnosis",
      "Subdiagnosis" = "subdiagnosis",
      "Number of samples" = "n"
    )
} else {
  # otherwise only count diagnosis
  diagnosis_table <- diagnosis_table |>
    dplyr::select(-subdiagnosis) |>
    dplyr::count(diagnosis) |>
    dplyr::arrange(desc(n)) |>
    dplyr::rename(
      "Diagnosis" = "diagnosis",
      "Number of samples" = "n"
    )
}

knitr::kable(diagnosis_table, align = "r") |>
  kableExtra::kable_styling(
    bootstrap_options = "striped",
    full_width = FALSE,
    position = "left"
  ) |>
  kableExtra::column_spec(2, monospace = TRUE)
```


```{r, eval=!is_multiplexed}
# TODO: Create a table with diagnosis + disease timing?
```


# Session Info
<details>
<summary>R session information</summary>
```{r session_info}
if (requireNamespace("sessioninfo", quietly = TRUE)) {
  sessioninfo::session_info()
} else {
  sessionInfo()
}
```
</details>
