<!-- This document contains function definitions that are used by both
`main_qc_report.rmd` and `celltypes_supplemental_report.rmd` to prepare
cell typing results for analysis/visualization 
These functions are only loaded in `main_qc_report.rmd` if cell types are present
-->


```{r}
library(SingleCellExperiment)

#' Create `celltype_df` data frame for use in cell type QC reports
#'
#' @param processed_sce The processed sce object with cell type annotations in colData
#'
#' @return `celltype_df` with column of cell types, as factors, for each annotation method
create_celltype_df <- function(processed_sce) {
  # only incorporate UMAP coordinates if present
  if ("UMAP" %in% reducedDimNames(processed_sce)) {
    celltype_df <- processed_sce |>
      scuttle::makePerCellDF(use.dimred = "UMAP") |>
      # rename UMAP columns as needed to remove potential period added by `scuttle::makePerCellDF`
      dplyr::rename_with(
        \(x) stringr::str_replace(x, "^UMAP\\.", "UMAP"),
        starts_with("UMAP")
      )
    # otherwise just grab the colData
  } else {
    celltype_df <- colData(processed_sce) |>
      as.data.frame()
  }

  celltype_df <- celltype_df |>
    # only keep columns of interest
    dplyr::select(
      barcodes,
      # account for potentially missing columns
      contains("cluster"),
      contains("UMAP"),
      contains("consensus"),
      contains("singler"),
      contains("cellassign"),
      contains("scimilarity"),
      contains("openscpca", ),
      contains("submitter")
    )

  if ("submitter_celltype_annotation" %in% names(celltype_df)) {
    celltype_df <- prepare_submitter_annotation_values(celltype_df)
  }
  if ("consensus_celltype_annotation" %in% names(celltype_df)) {
    celltype_df <- prepare_automated_annotation_values(
      celltype_df,
      consensus_celltype_annotation
    )
  }
  if ("singler_celltype_annotation" %in% names(celltype_df)) {
    celltype_df <- prepare_automated_annotation_values(
      celltype_df,
      singler_celltype_annotation
    )
  }
  if ("cellassign_celltype_annotation" %in% names(celltype_df)) {
    celltype_df <- prepare_automated_annotation_values(
      celltype_df,
      cellassign_celltype_annotation
    )
  }
  if ("scimilarity_celltype_annotation" %in% names(celltype_df)) {
    celltype_df <- prepare_automated_annotation_values(
      celltype_df,
      scimilarity_celltype_annotation
    )
  }

  # if openscpca annotations exist we just need to sort by frequency and recode unknown
  # we already label openscpca-excluded for any missing cells when we add to the object
  if ("openscpca_celltype_annotation" %in% names(celltype_df)) {
    celltype_df <- prepare_automated_annotation_values(
      celltype_df,
      openscpca_celltype_annotation
    )
  }

  return(celltype_df)
}


#' Prepare and reformat cell type automated annotation values for use in QC reports
#'  Unknown cell types are updated with the label "Unknown cell type", and
#'  cell types are ordered in order of descending frequency, but with
#'  "Unknown cell type" as the last level
#'
#' @param df The data frame containing cell type annotations, one row per cell
#' @param annotation_column The column (written plainly, not a string) containing annotations to reformat
#'
#' @return Updated data frame with the `annotation_column` reformatted
prepare_automated_annotation_values <- function(
    df,
    annotation_column) {
  unknown_string <- "Unknown cell type"

  df |>
    dplyr::mutate(
      {{ annotation_column }} := dplyr::case_when(
        # singler condition
        is.na({{ annotation_column }}) ~ unknown_string,
        # cellassign condition
        {{ annotation_column }} == "other" ~ unknown_string,
        # consensus condition
        {{ annotation_column }} == "Unknown" ~ unknown_string,
        # otherwise, keep it
        .default = {{ annotation_column }}
      ) |>
        # order column by number of cells
        forcats::fct_infreq() |>
        # make "Unknown cell type" the last level
        forcats::fct_relevel(unknown_string, after = Inf)
    )
}

#' Prepare and reformat cell type submitter annotation values for use in QC reports
#'  Unknown cell types, followed by "Submitter-excluded" (cells the submitter
#'  did not annotate) are set as the last levels
#'
#' @param df The data frame containing cell type annotations, one row per cell.
#'   Must contain the column `submitter_celltype_annotation`
#'
#' @return Updated data frame with the `annotation_column` reformatted
prepare_submitter_annotation_values <- function(df) {
  if (!("submitter_celltype_annotation" %in% names(df))) {
    stop("Could not process submitter annotation values; missing submitter column.")
  }

  # string for submitter-excluded cell types
  submitter_excluded_string <- "Submitter-excluded"

  # define baseline levels in descending order of frequency
  submitter_levels <- df$submitter_celltype_annotation |>
    # that this does not actually order the final factor - this is just for
    #  preparing to handle "unknown" levels
    forcats::fct_infreq() |>
    levels()

  # strings which might be "unknown"-y
  unknown_strings <- c("na", "nan", "null", "unknown", "")

  # remove non-word characters & make lower case
  # note by removing \\W, we match `<n/a>` and similar
  submitter_normalized_levels <- submitter_levels |>
    stringr::str_replace_all("\\W+", "") |>
    stringr::str_to_lower()

  # determine which of those levels are unknowns
  unknown_levels <- submitter_levels[submitter_normalized_levels %in% unknown_strings]

  # if submitter-excluded is present it should go at the VERY END regardless of count
  if (submitter_excluded_string %in% submitter_levels) {
    unknown_levels <- c(unknown_levels, submitter_excluded_string)
  }

  # Move unknown levels to the end in order of frequency, followed by submitter-excluded
  df$submitter_celltype_annotation <- df$submitter_celltype_annotation |>
    # still need to actually arrange by frequency first
    forcats::fct_infreq() |>
    # move unknowns, in order, to the end
    forcats::fct_relevel(unknown_levels, after = Inf)

  return(df)
}

#' Check if CellAssign was run or not
#'
#' @param has_cellassign Boolean indicating if CellAssign is present
#' @param sce_coldata colData slot of a processed SCE object
#'
#' @return TRUE if CellAssign was not run, FALSE if CellAssign was run
check_cellassign_not_run <- function(
    has_cellassign,
    sce_coldata) {
  if (!has_cellassign && "cellassign_celltype_annotation" %in% names(sce_coldata)) {
    # This means the values should all be `"Not run"`
    if (!(all(sce_coldata$cellassign_celltype_annotation == "Not run"))) {
      stop("Error: Unexpected CellAssign celltypes are present.")
    }

    cellassign_not_run <- TRUE
  } else {
    cellassign_not_run <- FALSE
  }

  return(cellassign_not_run)
}
```

<!-- Define helper functions for calculating Jaccard matrices -->
```{r}
#' Function to calculate Jaccard similarity on two vectors
#'
#' @param vec1 First vector
#' @param vec2 Second vector
#'
#' @return Jaccard similarity between the vectors
jaccard <- function(vec1, vec2) {
  length(intersect(vec1, vec2)) / length(union(vec1, vec2))
}


# Wrapper function to calculate jaccard similarity matrix for two categorical variables
#'
#' @param celltype_df The celltype_df data frame which must contain these columns:
#'   `colname1`, `colname2`, and `barcodes`
#' @param colname1 Column name, as a string, of first categorical variable of interest
#' @param colname2 Column name, as a string, of second categorical variable of interest
#'
#' @return Jaccard similarity matrix for the two columns. `colname1` values will
#'   be row names and `colname2` values will be column names in the final matrix
make_jaccard_matrix <- function(celltype_df, colname1, colname2) {
  # make lists of barcodes for each category, named by the category
  id1_list <- split(celltype_df$barcodes, celltype_df[[colname1]])
  id2_list <- split(celltype_df$barcodes, celltype_df[[colname2]])

  # create the grid of comparisons
  cross_df <- tidyr::expand_grid(id1 = names(id1_list), id2 = names(id2_list))

  # calculate a single Jaccard index for each combination using split lists & ids
  jaccard_scores <- cross_df |>
    purrr::pmap_dbl(\(id1, id2){
      jaccard(id1_list[[id1]], id2_list[[id2]])
    })

  # add scores to the comparison grid and convert to matrix
  jaccard_matrix <- cross_df |>
    dplyr::mutate(jaccard = jaccard_scores) |>
    # convert to matrix
    tidyr::pivot_wider(
      names_from = "id2",
      values_from = "jaccard"
    ) |>
    tibble::column_to_rownames(var = "id1") |>
    as.matrix()

  return(jaccard_matrix)
}
```


<!-- Define variables, options, and functions for plotting heatmaps -->
```{r}
# Define color ramp for shared use in the heatmap
heatmap_col_fun <- circlize::colorRamp2(c(0, 1), colors = c("white", "darkslateblue"))

# Set heatmap padding option
heatmap_padding <- 0.05
ComplexHeatmap::ht_opt(TITLE_PADDING = grid::unit(heatmap_padding, "in"))

#' Create a ComplexHeatmap from a matrix
#'
#' @param mat Matrix to create heatmap from.
#' @param row_title Label for row title.
#' @param column_title Label for column title.
#' @param labels_font_size Font size to use for rows and column labels.
#' @param keep_legend_name The name to use in the legend
#' @param col_fun Color function for the heatmap palette. Default is `heatmap_col_fun`.
#' @param ... Additional arguments to pass to `ComplexHeatmap::Heatmap()`
#'
#' @return A ComplexHeatmap object
create_single_heatmap <- function(
    mat,
    row_title,
    column_title,
    labels_font_size,
    keep_legend_name,
    col_fun = heatmap_col_fun,
    column_names_side = "bottom",
    ...) {
  heat <- ComplexHeatmap::Heatmap(
    t(mat), # transpose because matrix rows are in common & we want a vertical arrangement
    col = col_fun,
    border = TRUE, # each heatmap gets its own outline
    ## Row parameters
    cluster_rows = FALSE,
    row_title = row_title, # each heatmap gets its own title
    row_title_gp = grid::gpar(fontsize = 10),
    row_title_side = "right",
    row_title_rot = 0, # annotation types on right should be horizontal
    row_names_side = "left",
    row_names_gp = grid::gpar(fontsize = labels_font_size),
    ## Column parameters
    cluster_columns = FALSE,
    column_title = column_title,
    column_title_gp = grid::gpar(fontsize = 10),
    column_names_side = column_names_side,
    column_names_gp = grid::gpar(fontsize = labels_font_size), ### passed in args
    ...,
    ## Legend parameters
    heatmap_legend_param = list(
      title = "Jaccard index",
      direction = "horizontal",
      legend_width = unit(1.5, "in")
    ),
    # only keep legends that match `keep_legend_name`
    show_heatmap_legend = row_title == keep_legend_name,
  )

  return(heat)
}

#' Function to plot a vertically-stacked ComplexHeatmap from a list of matrices
#'
#' @param matrix_list List of matrices to plot in a vertical layout
#' @param column_title Title to use for columns, shared among all heatmaps
#' @param labels_font_size Font size to use for rows and column labels
#' @param col_fun Color function for the heatmap palette. Default is `heatmat_col_fun`
#' @param ... Additional arguments to pass to `ComplexHeatmap::Heatmap()`
#'
#' @return A list of ComplexHeatmap objects
create_heatmap_list <- function(
    matrix_list,
    column_title,
    labels_font_size,
    col_fun = heatmap_col_fun,
    ...) {
  # We only want one shared legend in the end, arbitrarily grab the first one
  keep_legend_name <- names(matrix_list)[1]

  heatmap_list <- matrix_list |>
    purrr::imap(
      \(mat, name) {
        # get the index of the list for mat
        idx <- which(names(matrix_list) == name)

        # if its the first one set the names to the top, otherwise bottom
        if (idx == 1) {
          column_names_side <- "top"
        } else {
          column_names_side <- "bottom"
        }

        create_single_heatmap(
          mat,
          name,
          column_title,
          labels_font_size,
          keep_legend_name,
          col_fun,
          column_names_side,
          ...
        )
      }
    ) |>
    # concatenate vertically into HeatmapList object
    purrr::reduce(ComplexHeatmap::`%v%`)

  return(heatmap_list)
}


#' Determine the label font size based on # characters in cell type labels
#'
#' @param input_labels Vector of cell type labels
#'
#' @return Font size numeric as determined by longest cell type label
find_label_size <- function(input_labels) {
  longest_name <- input_labels |>
    stringr::str_length() |>
    max()

  labels_font_size <- dplyr::case_when(
    longest_name < 35 ~ 9.5,
    longest_name < 45 ~ 8.5,
    longest_name < 60 ~ 7.5,
    .default = 6.5
  )

  return(labels_font_size)
}
```


```{r}
#' Function to calculate optimal heatmap plot view height
#'
#' @param row_names Vector of rownames
#' @param col_names Vector of column names
#' @param n_spacers Number of spacers between stacked heatmaps
#' @param spacer_size Spacer size in inches
#' @param min_height Minimum height required. Default 6"
#'
#' @return Heatmap height in inches
calculate_plot_height <- function(
    row_names,
    col_names,
    n_spacers,
    spacer_size = heatmap_padding,
    min_height = 6) {
  # first, based on number of cells in row_names:
  #   6 cell types to an inch
  heat_height <- length(row_names) / 6

  # next, based on nchar of col_names:
  #   10 characters to an inch
  # using stringr::str_length() in case col_names is a factor vector
  heat_height <- heat_height + max(stringr::str_length(col_names)) / 10

  # finally, add in any padding
  heat_height <- heat_height + n_spacers * spacer_size

  return(
    pmax(min_height, heat_height)
  )
}
```
