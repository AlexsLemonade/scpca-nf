---
params:
  library: Example
  processed_sce: NULL
  date: !r Sys.Date()

title: "`r glue::glue('ScPCA Cell type annotation supplemental QC report for {params$library}')`"
author: "Childhood Cancer Data Lab"
date: "`r params$date`"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
    number_sections: false
    code_download: true
---

```{r setup, message = FALSE, echo = FALSE}
# knitr options
knitr::opts_chunk$set(
  echo = FALSE
)

library(SingleCellExperiment)
library(ggplot2)

# Set default ggplot theme
theme_set(
  theme_bw() +
    theme(
      plot.margin = margin(rep(20, 4)),
      strip.background = element_rect(fill = "transparent")
    )
)
```

<!-- Import shared functions for cell type wrangling -->
```{r, child='utils/celltype_functions.rmd'}

```

<!-- Define helper functions for calculating Jaccard similarity matrices --> 
```{r}
#' Function to calculate Jaccard similarity on two vectors
#'
#' @param vec1 First vector
#' @param vec2 Second vector
#'
#' @return Jaccard similarity between the vectors
jaccard <- function(vec1, vec2){
  length(intersect(vec1, vec2)) / length(union(vec1, vec2))
}


# Wrapper function to calculate jaccard similarity matrix for two categorical variables
#'
#' @param celltype_df The celltype_df data frame which must contain these columns:
#'   `colname1`, `colname2`, and `barcodes`
#' @param colname1 Column name, as a string, of first categorical variable of interest
#' @param colname2 Column name, as a string, of second categorical variable of interest
#'   
#' @return Jaccard similarity matrix for the two columns. `colname1` values will 
#'   be row names and `colname2` values will be column names in the final matrix
make_jaccard_matrix <- function(celltype_df, colname1, colname2){
  
  # make lists of barcodes for each category, named by the category
  id1_list <- split(celltype_df$barcodes, celltype_df[[colname1]])
  id2_list <- split(celltype_df$barcodes, celltype_df[[colname2]])
  
  # create the grid of comparisons
  cross_df <- tidyr::expand_grid(id1 = names(id1_list), id2 = names(id2_list))
  
  # calculate a single Jaccard index for each combination using split lists & ids
  jaccard_scores <- cross_df |> 
    purrr::pmap_dbl(\(id1, id2){
      jaccard(id1_list[[id1]], id2_list[[id2]])
    })
  
  # add scores to the comparison grid and convert to matrix
  jaccard_matrix <- cross_df |> 
    dplyr::mutate(jaccard = jaccard_scores) |>
    # convert to matrix
    tidyr::pivot_wider(
      names_from = "id2", 
      values_from = "jaccard"
    ) |>
    tibble::column_to_rownames(var = "id1") |>
    as.matrix()
    
    return(jaccard_matrix)
}
```

<!-- Define variables, options, and function for plotting heatmap from list of matrices --> 
```{r}
# Define color ramp for shared use in the heatmap
heatmap_col_fun <- circlize::colorRamp2(c(0, 1), colors = c("white", "darkslateblue"))

# Set heatmap padding option
ComplexHeatmap::ht_opt(TITLE_PADDING = grid::unit(0.2, "in"))

#' Function to plot a ComplexHeatmap
#'
#' @param matrix_list List of matrices to plot in a vertical layout. 
#' @param col_fun Color function for the heatmap palette
#' @param column_title Title to use for columns, shared among all heatmaps
#'
#' @return Draws a ComplexHeatmap, but does not explicitly return anything
plot_heatmap <- function(matrix_list,
                         column_title, 
                         col_fun = heatmap_col_fun) {
  
  
  # We only want one shared legend in the end, arbitrarily grab the first one
  keep_legend_name <- names(matrix_list)[1]

    
  heatmap_list <- jaccard_cluster_matrices |> 
    purrr::imap(\(mat, name){
      ComplexHeatmap::Heatmap(
        t(mat), # transpose because matrix rows are in common & we want a vertical arrangement
        col = col_fun,
        border = TRUE, # each heatmap gets its own outline
        ## Row parameters
        cluster_rows = FALSE,
        row_title = name, # each heatmap gets its own title
        row_title_gp = grid::gpar(fontsize = 10), 
        row_title_side = "right",
        row_names_side = "left",
        row_names_gp = grid::gpar(fontsize = 8),
        ## Column parameters
        cluster_columns = FALSE,
        column_title = column_title,
        column_names_side = "top",
        column_names_rot = 0,
        column_names_gp = grid::gpar(fontsize = 8), # match row name size
        ## Legend parameters
        heatmap_legend_param = list(
          title = "Jaccard similarity index",
          direction = "horizontal",
          legend_width = unit(1.5, "in")
        ),
        # Retain only 1 legend in the final plot      
        show_heatmap_legend = name == keep_legend_name,
      )
    }) |>
    # concatenate vertically into HeatmapList object
    purrr::reduce(ComplexHeatmap::`%v%`) 
  
  
  # Render the heatmap list
  ComplexHeatmap::draw(
    heatmap_list, 
    heatmap_legend_side = "bottom" 
  )
  
}


```


```{r, message = FALSE, warning = FALSE, echo = FALSE}
# define library and sce object
library_id <- params$library
processed_sce <- params$processed_sce

# check for annotation methods
has_singler <- "singler" %in% metadata(processed_sce)$celltype_methods
has_cellassign <- "cellassign" %in% metadata(processed_sce)$celltype_methods
has_submitter <- "submitter" %in% metadata(processed_sce)$celltype_methods

# Create data frame of cell types
celltype_df <- create_celltype_df(processed_sce)
```


## Cell label comparison plots

This section displays heatmaps comparing cell labels from various methods. 

We use the [Jaccard similarity index](https://en.wikipedia.org/wiki/Jaccard_index) to display the agreement between between pairs of labels from different methods.

The Jaccard index reflects the degree of overlap between the two labels and ranges from 0 to 1. 

* If the labels are assigned to identical sets of cells, the Jaccard index will be 1.
* If the labels are assigned to completely non-overlapping sets of cells, the Jaccard index will be 0.


### Comparison with unsupervised clustering

Here we show the labels from unsupervised clustering compared against cell type annotations. 
Cluster assignment was performed using the `r metadata(processed_sce)$cluster_algorithm` algorithm.


```{r}
# Calculate all jaccard matrices of interest for input to heatmap
jaccard_cluster_matrices <- list()

if (has_submitter) {
  jaccard_cluster_matrices[["Submitter"]] <- make_jaccard_matrix(
    celltype_df, 
    "cluster", 
    "submitter_celltype_annotation"
  )
}
if (has_singler) {
  jaccard_cluster_matrices[["SingleR"]] <- make_jaccard_matrix(
    celltype_df, 
    "cluster", 
    "singler_celltype_annotation"
  )
}
if (has_cellassign) {
  jaccard_cluster_matrices[["CellAssign"]] <- make_jaccard_matrix(
    celltype_df, 
    "cluster", 
    "cellassign_celltype_annotation"
  )
}


heatmap_height <- length(jaccard_cluster_matrices) * 2.5
```

```{r, fig.height = heatmap_height, fig.width = 7, warning = FALSE}
plot_heatmap(jaccard_cluster_matrices, "Clusters")
```





```{r, eval = has_submitter & (has_cellassign | has_singler)}
methods_string <- dplyr::case_when(
  has_cellassign & has_singler ~ "`SingleR` and `CellAssign`",
  has_singler  ~ "`SingleR`",
  has_cellassign  ~ "`CellAssign`"
)

knitr::asis_output(
  glue::glue(
  "## Comparison with submitter annotations

  This section displays heatmaps comparing submitter-provided cell type annotations to those obtained from {methods_string}."
  )
)

```


```{r, eval = has_cellassign & has_singler, fig.height=7, fig.width=8}
knitr::asis_output("
### Comparison between `SingleR` and `CellAssign` annotations

This section displays a heatmap directly comparing `SingleR` and `CellAssign` cell type annotations.
Note that due to different annotations references, these methods may use different names for similar cell types.
")
```




```{r, eval = has_singler | has_cellassign }
knitr::asis_output("
## Annotation Assessment

In this section, we assess the reliability of cell type annotations using diagnostic plots.
")
```

```{r, eval = has_singler}
knitr::asis_output("
### `SingleR` assessment

To assess the quality of the `SingleR`-assigned cell types, we use the _delta median_ statistic.

- _Delta median_ is calculated for each cell as the difference between the `SingleR` score of the assigned cell type label and the median score of the other cell type labels in the reference dataset.
- Higher _delta median_ values indicate higher quality cell type annotations.
  - Values can range from 0-1.
  - Note that there is no universal threshold for calling absolute high vs. low quality, as described in the [`SingleR` book section on 'Annotation diagnostics'](https://bioconductor.org/books/release/SingleRBook/annotation-diagnostics.html#annotation-diagnostics).

You can interpret this plot as follows:

- Each point represents the _delta median_ statistic of a given cell whose assigned `SingleR` annotation is shown on the y-axis.
- The point color indicates `SingleR`'s quality assessment of the annotation:
  - High-quality cell annotations are shown as closed points.
  - Low-quality cell annotations are shown as open points.
  In other sections of this report, these cells are referred to as `Unknown cell types`.
  - For more information on how `SingleR` calculates annotation quality, please refer to [this `SingleR` documentation](https://rdrr.io/bioc/SingleR/man/pruneScores.html).
- Red diamonds represent the median _delta median_ statistic among high-quality annotations for the given cell type label.
")
```


```{r, eval = has_singler, warning=FALSE, message=FALSE}
# Prepare SingleR scores for plot

# extract scores into matrix
singler_scores <- metadata(processed_sce)$singler_result$scores

# Create data frame for plotting with delta median and the full *non-pruned* cell labels
delta_median_df <- tibble::tibble(
  delta_median = rowMaxs(singler_scores) - rowMedians(singler_scores),
  # Need to grab the non-pruned label for this plot
  full_labels = metadata(processed_sce)$singler_result$labels,
  # if pruned.labels are NA ==> low confidence
  # so, negate for this variable:
  confident = !is.na(metadata(processed_sce)$singler_result$pruned.labels)
) |>
  dplyr::mutate(confident =
    ifelse(confident, "High-quality", "Low-quality")
  )

# If ontologies were used for `full_labels`, we'll need to map back to cell type names
#  for the plot itself.
if ("singler_celltype_ontology" %in% names(celltype_df)) {
  # we use inner_join b/c the above tibble does NOT contain "Unknown cell type", which
  #  we do not want to display here
  delta_median_df <- delta_median_df |>
    dplyr::inner_join(
      tibble::tibble(
        full_labels = celltype_df$singler_celltype_ontology,
        celltype = celltype_df$singler_celltype_annotation
      ) |> dplyr::distinct()
    ) |>
    dplyr::select(-full_labels)
} else {
  # otherwise, full_labels already contain what we want to plot, so just rename it
  delta_median_df <- delta_median_df |>
    dplyr::rename(celltype = full_labels)
  # still need to add levels:
  # Note that the level "Unknown cell type" will still be present, but there is no such value in the data, so it won't matter
  levels(delta_median_df$celltype) <- levels(celltype_df$singler_celltype_annotation)
}

# Ensure we have no "Unknown cell type" values left:
if (any(delta_median_df$celltype == "Unknown cell type")) {
  stop("Failed to process SingleR data for diagnostic plot.")
}

# add column with ordered levels with wrapped labels for visualization
delta_median_df$annotation_wrapped <- factor(
  delta_median_df$celltype,
  # rev() so large groups are at the TOP of the plot
  levels = rev(levels(delta_median_df$celltype)),
  labels = rev(stringr::str_wrap(levels(delta_median_df$celltype), 30))
)

# Subset the data to just confident points for median+/-IQR
delta_median_confident_df <- delta_median_df |>
  dplyr::filter(confident == "High-quality")

# Determine height for plot area based on number of cells
plot_height <- length(unique(delta_median_df$celltype))/2.5
```

```{r, eval = has_singler, warning=FALSE, message=FALSE, fig.height = plot_height, fig.width = 6.5}
# Plot delta_median across celltypes colored by pruning
ggplot(delta_median_df) +
  aes(
    x = delta_median,
    y = annotation_wrapped,
    shape = confident,
    alpha = confident
  ) +
  ggforce::geom_sina(
    size = 0.8,
    color = "black", # will get applied to all confident points and non-confident outline
    fill = "white", # will apply to non-confident fill only
    position = position_dodge(width = 0.05) # Keep both types of points mostly in line
  ) +
  # Handle points aesthetics:
  #  confident are closed black with alpha = 0.5
  #  not confident are open black with alpha = 1
  scale_shape_manual(values = c(19, 21)) +
  scale_alpha_manual(values = c(0.5, 1)) +
  labs(
    x = "Delta median statistic",
    y = "Cell type annotation",
    shape = "Cell type annotation quality"
  ) +
  # add median diamond for confident points only
  stat_summary(
    data = delta_median_confident_df,
    color = "red",
    geom = "point",
    fun = "median",
    shape = 18,
    size = 2.25,
    alpha = 0.9
  ) +
  guides(
    alpha = FALSE,
    shape = guide_legend(override.aes = list(size = 1.5, alpha = 0.55))
  ) +
  theme(
    legend.position = "bottom"
  )
```



```{r, eval = has_cellassign}
knitr::asis_output("
### `CellAssign` assessment

`CellAssign` computes the probability that each cell in the library is one of the provided cell types in the reference and ultimately annotates cells by assigning the cell type with the highest probability.
We therefore expect that cell-level probabilities that correspond to the annotated cell types will be high.
Conversely, we expect that cell-level probabilities that correspond to unannotated cell types will be low.

In the plot below, we show distributions of the `CellAssign` probabilities for each assigned cell type, where the median is shown as a vertical line in each.
Colors represent whether the probabilities correspond to a cell with that given annotation: Purple distributions represent probabilies for cells that _were_ annotated as the given cell type.
Yellow distributions represent probabilities for cells that _were not_ annotated as the given cell type.
For distributions with fewer than three points, density plots cannot be calculated.
In these cases, we directly show values for individual cell probabilities as line segments.
")
```


```{r, eval = has_cellassign, warning=FALSE, message=FALSE, fig.height = 8, fig.width = 7}
# Prepare CellAssign scores for plot
cellassign_prob_df <- metadata(processed_sce)$cellassign_predictions |>
  # Change "other" to "Unknown cell type"
  dplyr::rename(`Unknown cell type` = other) |>
  tidyr::pivot_longer(
    -barcode,
    names_to = "celltype",
    values_to = "probability"
  ) |>
  # remove cell types that were not annotated
  dplyr::filter(celltype %in% celltype_df$cellassign_celltype_annotation) |>
  # join with actual annotations
  dplyr::inner_join(
    tibble::tibble(
      cellassign_celltype_annotation = celltype_df$cellassign_celltype_annotation,
      barcode = colData(processed_sce)$barcodes # plural!
    )
  ) |>
  # add indicator for whether the celltype matches the annotation
  dplyr::mutate(
    annotated = cellassign_celltype_annotation == celltype
  )

# reverse levels for ridgeplot layout, and wrap the labels
new_levels <- rev(levels(cellassign_prob_df$cellassign_celltype_annotation))
cellassign_prob_df$annotation_wrapped <- factor(
  cellassign_prob_df$celltype,
  levels = new_levels,
  labels = stringr::str_wrap(new_levels, 30)
)

# find groups with <=2 cells to add back into plot
# These will always be `annotated = TRUE`
celltypes_leq2_cells <- cellassign_prob_df |>
  dplyr::count(annotation_wrapped, annotated) |>
  dplyr::filter(n <= 2) |>
  dplyr::pull(annotation_wrapped)

# data frame for adding those points back
leq2_probabilities_df <- cellassign_prob_df |>
  dplyr::filter(
    annotation_wrapped %in% celltypes_leq2_cells,
    annotated
  ) |>
  dplyr::select(annotation_wrapped, probability, annotated)

# Finally, the plot:
ggplot(cellassign_prob_df) +
  aes(
    x = probability,
    y = annotation_wrapped,
    fill = annotated
  ) +
  ggridges::stat_density_ridges(
    quantile_lines = TRUE,
    quantiles = 2,
    alpha = 0.6,
    # avoid overlap to extent possible in a template -
    scale = 0.85
  ) +
  scale_fill_viridis_d(direction = -1) +
  labs(
    x = "CellAssign probability",
    y = "Annotated cell type",
    fill = "Cell annotated as given cell type"
  ) +
  theme(
    axis.text.y = element_text(size = 9),
    legend.position = "bottom"
  ) +
  #### add line segment for N<3 distributions
  geom_segment(
    data = leq2_probabilities_df,
    aes(
      x = probability,
      xend = probability,
      y = annotation_wrapped,
      yend = as.numeric(annotation_wrapped) + 0.25,
      color = annotated
    ),
    show.legend = FALSE
  ) +
  scale_color_viridis_d()
```

