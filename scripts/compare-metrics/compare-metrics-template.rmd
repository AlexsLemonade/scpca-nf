---
params:
  reference_s3: s3://nextflow-ccdl-results/scpca-prod/results
  comparison_s3: s3://nextflow-ccdl-results/scpca-staging/results
  project_id: "all"
  use_cache: false
title: "`scpca-nf` Metrics Comparison"
subtitle: "Project: `r params$project_id`"
author: "Childhood Cancer Data Lab"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    code_folding: hide
---

```{r setup}
#| include: false
library(ggplot2)

knitr::opts_chunk$set(
  echo = FALSE
)

use_cache <- params$use_cache && file.exists("metrics.rds")

set.seed(1234)
```

```{r}
# Functions
#| include: false


read_metrics_files <- function(urls) {
  # read a set of metrics files
  # url: URL of the metrics files, each in json format
  # returns: data frame (tibble) of combined metrics
  purrr::map(urls, \(url) {
    jsonlite::read_json(url, simplifyVector = TRUE) |>
      # handle bare NAs, which may be quoted
      purrr::modify_if(\(x){
        length(x) == 1 && x == "NA"
      }, ~NA)
  }) |>
    purrr::list_transpose(default = NA) |>
    tibble::as_tibble()
}

report_table <- function(df, options = list(), ...) {
  # pass standard settings for report to DT::datatable
  # df: data frame to display
  # options: list of options to pass to DT::datatable
  # ...: additional arguments to pass to DT::datatable
  default_opts <- list(
    scroller = TRUE,
    deferRender = TRUE,
    scrollX = TRUE,
    scrollY = 400,
    scrollCollapse = TRUE,
    language = list(search = "Filter:"),
    columnDefs = list(list(
      # render missing values as "NA" rather than blanks in the table
      targets = "_all",
      render = DT::JS(
        "function(data, type, row, meta) {",
        "return data === null ? 'NA' : data;",
        "}"
      )
    ))
  )

  if (length(options) > 0) {
    # merge default options with user options
    opts <- modifyList(default_opts, options)
  } else {
    opts <- default_opts
  }
  DT::datatable(
    df,
    rownames = FALSE,
    extensions = "Scroller",
    options = opts,
    ...
  )
}
```

```{r, eval=!use_cache}
#| include: false
# get metrics files by scanning S3
if (tolower(params$project_id[1]) == "all") {
  metrics_regex <- "SCPCL[0-9]{6}_metrics.json$"
} else {
  metrics_regex <- paste0("(", params$project_id, ".+SCPCL[0-9]{6}_metrics.json$)", collapse = "|")
}

ref_metrics_files <- s3fs::s3_dir_ls(
  params$reference_s3,
  recurse = TRUE,
  regexp = metrics_regex
) |>
  s3fs::s3_file_url() # get signed URLs for reading

comp_metrics_paths <- s3fs::s3_dir_ls(
  params$comparison_s3,
  recurse = TRUE,
  regexp = metrics_regex
) |>
  s3fs::s3_file_url()
```

```{r, eval=!use_cache}
#| include: false
# read metrics files from S3
ref_data <- read_metrics_files(ref_metrics_files)
comp_data <- read_metrics_files(comp_metrics_paths)

# join the two data frames
metrics_df <- dplyr::full_join(
  ref_data,
  comp_data,
  by = c("project_id", "sample_id", "library_id"),
  suffix = c(".ref", ".comp")
)
# temporary write for testing
readr::write_rds(metrics_df, "metrics.rds")
```

```{r, eval=use_cache}
#| include: false
# temporary chunk for testing
metrics_df <- readr::read_rds("metrics.rds")
```


## Project and sample changes

```{r}
# filter to get added or removed samples
lib_changes <- metrics_df |>
  dplyr::filter(if_any(starts_with("mapped_reads"), is.na)) |>
  dplyr::mutate(
    added_removed = ifelse(is.na(mapped_reads.ref), "Added", "Removed")
  ) |>
  dplyr::select(
    project_id,
    sample_id,
    library_id,
    added_removed
  )
```

```{r}
# Text summary of added/removed libraries
if (nrow(lib_changes) == 0) {
  knitr::asis_output(
    "There are no added or removed libraries."
  )
} else {
  n_added <- sum(lib_changes$added_removed == "Added")
  n_removed <- sum(lib_changes$added_removed == "Removed")
  n_projects <- dplyr::n_distinct(lib_changes$project_id)

  glue::glue("
    Below is a table of added or removed samples and libraries.<br>
    There {ifelse(n_added == 1, 'is', 'are')} **{n_added}** added {ifelse(n_added == 1, 'library', 'libraries')} and
    **{n_removed}** removed {ifelse(n_removed == 1, 'library', 'libraries')}.

    These come from **{n_projects}** {ifelse(n_projects == 1, 'project', 'projects')}.


  ") |>
    knitr::asis_output()
}
```

```{r, eval = nrow(lib_changes) > 0}
report_table(
  lib_changes,
  colnames = c("Project", "Sample", "Library", "Added/Removed")
)
```


## Processing changes {.tabset}

```{r}
processing_fields <- c(
  "droplet_filtering_method",
  "normalization_method",
  "cell_filtering_method",
  "cluster_algorithm",
  "singler_reference",
  "cellassign_reference"
)

processing_changes <- metrics_df |>
  tidyr::drop_na(starts_with("mapped_reads")) |> # remove added/removed libraries
  dplyr::select(
    project_id,
    sample_id,
    library_id,
    starts_with(processing_fields)
  ) |>
  tidyr::pivot_longer(
    cols = starts_with(processing_fields),
    names_pattern = "(.+)\\.(ref|comp)$",
    names_to = c("field", ".value") # .value separates into `ref` and `comp` fields
  ) |>
  dplyr::filter(
    ref != comp
  )

has_processing_changes <- nrow(processing_changes) > 0
```

```{r}
# Text summary of processing changes
if (!has_processing_changes) {
  knitr::asis_output(
    "All processing fields are the same between the reference and comparison runs."
  )
} else {
  n_projects <- dplyr::n_distinct(processing_changes$project_id)
  n_libraries <- dplyr::n_distinct(processing_changes$library_id)

  glue::glue("
    The tables below show the processing changes between the reference and comparison workflow runs.<br>
    There {ifelse(n_added == 1, 'is', 'are a total of')} **{n_libraries}** {ifelse(n_libraries == 1, 'library', 'libraries')} with processing changes
    from **{n_projects}** {ifelse(n_projects == 1, 'project', 'projects')}.
  ") |>
    knitr::asis_output()
}
```


```{r, eval=has_processing_changes}
knitr::asis_output("### Summary")
```

```{r, eval=has_processing_changes}
processing_summary <- processing_changes |>
  dplyr::count(
    field,
    ref,
    comp,
    name = "n_changed"
  )

report_table(
  processing_summary,
  colnames = c("Processing field", "Reference value", "Comparison value", "Number of libraries changed")
)
```


```{r, eval=has_processing_changes}
knitr::asis_output("### Detail")
```

```{r, eval=has_processing_changes}
report_table(
  processing_changes,
  colnames = c("Project", "Sample", "Library", "Field", "Reference value", "Comparison value")
)
```

## Changes in cell and read counts

### Cell count changes {.tabset}

```{r}
# calculate the difference between reference and comparison for selected fields

cell_fields <- c(
  "unfiltered_cells",
  "filtered_cells",
  "processed_cells",
  "miqc_pass_count",
  "scpca_filter_count",
  "adt_scpca_filter_count"
)

cell_changes <- metrics_df |>
  tidyr::drop_na(starts_with("mapped_reads")) |> # remove added/removed libraries
  dplyr::select(
    project_id,
    sample_id,
    library_id,
    starts_with(cell_fields)
  ) |>
  tidyr::pivot_longer(
    cols = starts_with(cell_fields),
    names_pattern = "(.+)\\.(ref|comp)$",
    names_to = c("field", ".value") # .value separates into `ref` and `comp` fields
  ) |>
  dplyr::filter(is.finite(comp) | is.finite(ref)) |> # keep where at least one is finite
  dplyr::mutate(
    change = comp - ref,
    change_frac = change / ref
  )

changed_cell_counts <- cell_changes |>
  dplyr::filter(is.na(change) | change != 0)

has_cell_changes <- nrow(changed_cell_counts) > 0
```

```{r}
# summary text for cell count section
if (!has_cell_changes) {
  knitr::asis_output(
    "There are no changes in cell counts between the reference and comparison runs."
  )
} else {
  n_projects <- dplyr::n_distinct(changed_cell_counts$project_id)
  n_libraries <- dplyr::n_distinct(changed_cell_counts$library_id)

  glue::glue("
    The tables below show changes in cell counts between the reference and comparison workflow runs at various stages of processing.<br>
    There {ifelse(n_added == 1, 'is', 'are a total of')} **{n_libraries}** {ifelse(n_libraries == 1, 'library', 'libraries')} with cell count changes
    from **{n_projects}** {ifelse(n_projects == 1, 'project', 'projects')}.
  ") |>
    knitr::asis_output()
}
```

```{r}
# warn if any unfiltered cell counts have changed
unfiltered_cell_changes <- changed_cell_counts |>
  dplyr::filter(stringr::str_detect(field, "^unfiltered_")) |>
  nrow()

if (unfiltered_cell_changes > 0) {
  glue::glue("
    <div class=\"alert alert-danger\">
    **Warning**: Unfiltered cell counts have changed between the reference and comparison runs.
    **{unfiltered_cell_changes}** {ifelse(unfiltered_cell_changes == 1, 'library is', 'libraries are')} affected.
    </div>
  ") |>
    knitr::asis_output()
}
```

```{r, eval=has_cell_changes}
knitr::asis_output("#### Summary")
```

```{r}
# Summary table of cell count changes

cell_field_n <- cell_changes |>
  dplyr::count(field)

cell_summary <- changed_cell_counts |>
  dplyr::summarise(
    .by = c("field"),
    n_changed = sum(is.na(change) | change != 0),
    mean_change_frac = mean(abs(change_frac[which(change != 0)]))
  ) |>
  dplyr::left_join(cell_field_n, by = "field") |>
  dplyr::mutate(
    library_change_frac = n_changed / n
  ) |>
  dplyr::select(
    field,
    n,
    n_changed,
    library_change_frac,
    mean_change_frac
  )

report_table(
  cell_summary,
  colnames = c("Metric", "Libraries", "Number of libraries changed", "% of libraries changed", "Mean % change")
) |>
  DT::formatPercentage(c("library_change_frac", "mean_change_frac"), 2)
```


```{r}
# summary plot
cell_plot_df <- changed_cell_counts |>
  tidyr::drop_na(change_frac) # remove NAs for plotting

ggplot(cell_plot_df, aes(x = change_frac)) +
  geom_histogram(bins = 20) +
  facet_wrap(vars(field), ncol = 3) +
  labs(
    title = "Histogram of changes in cell counts",
    x = "Change proportion",
    y = "Number of samples"
  ) +
  theme_bw()
```

```{r, eval=has_cell_changes}
knitr::asis_output("#### Detail")
```

```{r}
# Detail table of cell count changes

cell_detail <- changed_cell_counts |>
  dplyr::select(
    project_id,
    sample_id,
    library_id,
    field,
    ref,
    comp,
    change,
    change_frac
  )

report_table(
  cell_detail,
  colnames = c("Project", "Sample", "Library", "Metric", "Reference", "Comparison", "Change", "% change")
) |>
  DT::formatPercentage("change_frac", 2)
```



### Read count changes {.tabset}


```{r}
# calculate the read count differences between reference and comparison for selected fields
read_fields <- c(
  "unfiltered_total_counts",
  "unfiltered_total_spliced",
  "unfiltered_expressed_genes",
  "filtered_total_counts",
  "filtered_total_spliced",
  "filtered_expressed_genes",
  "processed_total_counts",
  "processed_total_spliced",
  "processed_total_logcounts",
  "processed_expressed_genes",
  "unfiltered_altexp_total",
  "filtered_altexp_total",
  "processed_altexp_total"
)

read_changes <- metrics_df |>
  tidyr::drop_na(starts_with("mapped_reads")) |> # remove added/removed libraries
  dplyr::select(
    project_id,
    sample_id,
    library_id,
    starts_with(read_fields)
  ) |>
  tidyr::unnest_wider( # create columns for separated altexps
    contains("altexp"),
    names_sep = "_"
  ) |>
  dplyr::rename_with( # rename altexp columns to keep ref/comp at end
    \(name) stringr::str_replace(name, "\\.(ref|comp)(_.+)$", "\\2.\\1"),
    contains("altexp")
  ) |>
  tidyr::pivot_longer(
    cols = starts_with(read_fields),
    names_pattern = "(.+)\\.(ref|comp)$",
    names_to = c("field", ".value") # .value separates into `ref` and `comp` fields
  ) |>
  dplyr::filter(is.finite(comp) | is.finite(ref)) |> # keep where at least one is finite
  dplyr::mutate(
    change = comp - ref,
    change_frac = change / ref
  )

changed_read_counts <- read_changes |>
  dplyr::filter(is.na(change) | change != 0) |>
  dplyr::mutate(
    # make corresponding field names for cell counts
    cell_count_field = stringr::str_replace(field, "^(.+?)_.+", "\\1_cells")
  ) |>
  dplyr::anti_join(
    # remove rows that have corresponding cell count changes
    # adt_scpca_filter_count does not filter cells, so we don't want to include those
    changed_cell_counts,
    by = c("project_id", "sample_id", "library_id", "cell_count_field" = "field")
  )

has_read_changes <- nrow(changed_read_counts) > 0
```

```{r}
# summary text for read count section
if (!has_read_changes && !has_cell_changes) {
  knitr::asis_output(
    "There are no changes in read counts between the reference and comparison runs."
  )
} else if (!has_read_changes) {
  knitr::asis_output(
    "There may be changes in read counts, but only those expected due to changes in cell counts as described above."
  )
} else {
  n_projects <- dplyr::n_distinct(changed_read_counts$project_id)
  n_libraries <- dplyr::n_distinct(changed_read_counts$library_id)
  glue::glue("
    The tables below show changes in read counts between the reference and comparison workflow runs at various stages of processing.
    These include only changes that are not expected based on changes in cell counts.<br>
    There {ifelse(n_added == 1, 'is', 'are a total of')} **{n_libraries}** {ifelse(n_libraries == 1, 'library', 'libraries')}
    with read count changes from **{n_projects}** {ifelse(n_projects == 1, 'project', 'projects')}.
  ") |>
    knitr::asis_output()
}
```


```{r}
# warn if any unfiltered read counts have changed
unfiltered_read_changes <- changed_read_counts |>
  dplyr::filter(stringr::str_detect(field, "^unfiltered_")) |>
  nrow()

if (unfiltered_read_changes > 0) {
  glue::glue("
    <div class=\"alert alert-danger\">
    **Warning**: Total reads for unfiltered cells have changed between the reference and comparison runs.
    **{unfiltered_read_changes}** {ifelse(unfiltered_read_changes == 1, 'library is', 'libraries are')} affected.
    </div>
  ") |>
    knitr::asis_output()
}
```

```{r, eval=has_read_changes}
knitr::asis_output("#### Summary")
```

```{r eval=has_read_changes}
# Summary table of read count changes
read_field_n <- read_changes |>
  dplyr::count(field)

read_summary <- changed_read_counts |>
  dplyr::summarise(
    .by = c("field"),
    n_changed = sum(is.na(change) | change != 0),
    mean_change_frac = mean(abs(change_frac[which(change != 0)]))
  ) |>
  dplyr::left_join(read_field_n, by = "field") |>
  dplyr::mutate(
    library_change_frac = n_changed / n
  ) |>
  dplyr::select(
    field,
    n,
    n_changed,
    library_change_frac,
    mean_change_frac
  )

report_table(
  read_summary,
  colnames = c("Metric", "Libraries", "Number of libraries changed", "% of libraries changed", "Mean % change")
) |>
  DT::formatPercentage(c("library_change_frac", "mean_change_frac"), 2)
```

```{r eval=has_read_changes}
# Plot of read count changes
read_plot_df <- changed_read_counts |>
  tidyr::drop_na(change_frac) # remove NAs for plotting

ggplot(read_plot_df, aes(x = change_frac)) +
  geom_histogram(bins = 20) +
  facet_wrap(vars(field), ncol = 3, scales = "free_x") +
  labs(
    title = "Histogram of changes in read counts",
    x = "Change proportion",
    y = "Number of samples"
  ) +
  theme_bw()
```

```{r, eval=has_read_changes}
knitr::asis_output("#### Detail")
```

```{r eval=has_read_changes}
# Detail table of read count changes
read_detail <- changed_read_counts |>
  dplyr::select(
    project_id,
    sample_id,
    library_id,
    field,
    ref,
    comp,
    change,
    change_frac
  )
report_table(
  read_detail,
  colnames = c("Project", "Sample", "Library", "Metric", "Reference", "Comparison", "Change", "% change")
) |>
  DT::formatPercentage("change_frac", 2)
```

## Analysis changes

### Highly variable genes

Here we will report changes in the sets of HVGs, both in the set of genes and the order.

### Clustering

Report changes in the number of clusters, as well as changes in the sizes of the assigned clusters.
We will ignore changes in the ordering of clusters by sorting by cluster size before comparisons.
As a summary statistic, we might use adjusted Rand index (ARI) or adjusted mutual information (AMI) to compare the two sets of clusters, reporting when we are well below 1.

### Cell type assignments

Report changes to the set of cell types assigned, and to the number of cells for each cell type.
This will include SingleR, CellAssign and consensus cell types, if present.

My initial thought is to use the Euclidean distance between the sets of cell type assignments here (since the assignment values do matter), though we could also look at ARI or AMI.


## Session Info
<details>
<summary>Click to expand</summary>
```{r}
sessionInfo()
```
</details>
