# Cell type Annotation Summary

<!--
This file is meant to be run as a child report within either `main_qc_report.rmd` or `celltypes_supplemental_report.rmd`. 
-->


```{r}
## function definitions ##

#' Create tables of cell type annotation counts
#'
#' @param df Data frame with cell types
#' @param celltype_column Column with cell type annotations, not a string.
#'
#' @return table with cell type counts
create_celltype_n_table <- function(df, celltype_column) {
  df |>
    dplyr::count({{ celltype_column }}) |>
    # Add percentage column
    dplyr::mutate(
      `Percent of cells` = paste0(round(n / sum(n) * 100, digits = 2), "%")
    ) |>
    # set column order & rename
    dplyr::select(
      `Annotated cell type` = {{ celltype_column }},
      `Number of cells` = n,
      `Percent of cells`
    )
}

#' Format tables of cell type counts as kable
#'
#' @param df Data frame to format
#'
#' @return kable table of cell type counts
format_celltype_n_table <- function(df) {
  df |>
    knitr::kable(align = "r") |>
    kableExtra::kable_styling(
      bootstrap_options = "striped",
      full_width = FALSE,
      position = "left"
    ) |>
    kableExtra::column_spec(2, monospace = TRUE)
}

#' Function to lump celltype columns in an existing data frame for all of the
#'  following columns, if they exist: `<singler/cellassign/submitter>_celltype_annotation`.
#' The cell types will also be renamed via wrapping at the given `wrap` level.
#'  The resulting lumped column will be named:
#'  `<singler/cellassign/submitter>_celltype_annotation_lumped`.
#'
#'
#' @param df Data frame to manipulate
#' @param n_celltypes Number of groups to lump into, with rest put into "Other" group. Default is 7.
#'
#' @return Updated df with new column of lumped celltypes for each present method
lump_wrap_celltypes <- function(df, n_celltypes = 7, wrap = 35) {
  df <- df |>
    # First, wrap labels
    dplyr::mutate(
      across(
        ends_with("_celltype_annotation"),
        \(x) stringr::str_wrap(x, wrap)
      )
    ) |>
    # Next, apply factor lumping, but ensure final order is via frequency with the "others" at the end
    dplyr::mutate(
      across(
        ends_with("_celltype_annotation"),
        \(x) {
          x |>
            forcats::fct_lump_n(n_celltypes, other_level = "All remaining cell types", ties.method = "first") |>
            forcats::fct_infreq() |>
            forcats::fct_relevel("Unknown cell type", "All remaining cell types", after = Inf)
        },
        .names = "{.col}_lumped"
      )
    )
  return(df)
}


#' Create a faceted UMAP panel where each panel has only one cell type colored
#'
#' @param umap_df Data frame with UMAP1 and UMAP2 columns
#' @param n_celltypes The number of cell types (facets) displayed in the plot
#' @param annotation_column Column containing cell type annotations
#' @param point_size Point size. Default is 1
#'
#' @return ggplot object containing a faceted UMAP where each cell type is a facet.
#'   In each panel, the cell type of interest is colored and all other cells are grey.
faceted_umap <- function(umap_df,
                         n_celltypes,
                         annotation_column,
                         point_size = 1) {
  # Determine legend y-coordinate based on n_celltypes
  if (n_celltypes %in% 7:8) {
    legend_y <- 0.33
  } else if (n_celltypes %in% 4:5) {
    legend_y <- 0.52
  }

  # color by the annotation column but only color one cell type at a time
  faceted_umap <- ggplot(
    umap_df,
    aes(x = UMAP1, y = UMAP2, color = {{ annotation_column }})
  ) +
    # set points for all "other" points
    geom_point(
      data = dplyr::select(
        umap_df, -{{ annotation_column }}
      ),
      color = "gray80",
      alpha = 0.5,
      size = point_size
    ) +
    # set points for desired cell type
    geom_point(size = point_size, alpha = 0.5) +
    facet_wrap(
      vars({{ annotation_column }}),
      ncol = 3
    ) +
    scale_color_brewer(palette = "Dark2") +
    # remove axis numbers and background grid
    scale_x_continuous(labels = NULL, breaks = NULL) +
    scale_y_continuous(labels = NULL, breaks = NULL) +
    guides(
      color = guide_legend(
        title = "Cell types",
        byrow = TRUE,
        # more visible points in legend
        override.aes = list(
          alpha = 1,
          size = 1.5
        )
      )
    )

  # Determine legend placement based on total_celltypes
  if (n_celltypes == 1) {
    # If n=1, we do not need to a show a legend, and title should be smaller
    faceted_umap <- faceted_umap +
      theme(
        legend.position = "none",
        plot.title = element_text(size = rel(0.85)),
        aspect.ratio = 1
      )
  } else if (n_celltypes %% 3 != 0 & n_celltypes > 2) {
    # This condition places the legend in the bottom right corner. Can use this for
    #  any n that doesn't have a full 3 columns, with one exception: for n=2,
    #  there will be no third column in the faceting to slot the legend into,
    #  so its legend has to go on the bottom
    faceted_umap <- faceted_umap +
      theme(
        legend.position = c(0.67, legend_y),
        legend.justification = c("left", "top"),
        legend.title.align = 0.5,
        # use slightly smaller legend text, which helps legend fit and prevents
        #  long wrapped labels from bunching up
        legend.text = element_text(size = rel(0.85)),
        legend.key.height = unit(0.75, "cm"),
        aspect.ratio = 1
      )
  } else {
    # For any other n, place legend on the bottom
    faceted_umap <- faceted_umap +
      theme(
        legend.position = "bottom",
        aspect.ratio = 1
      )
  }



  return(faceted_umap)
}

#' Determine dimension for UMAP plot display based on number of cell types
#'
#' @param n_celltypes Number of cell types (here, facets) displayed in plot
#'
#' @return A vector of c(width, height) in inches
determine_umap_dimensions <- function(n_celltypes) {
  dplyr::case_when(
    n_celltypes == 1 ~ c(3.75, 3.5), # 1: no legend
    n_celltypes == 2 ~ c(5.5, 5), # 2: bottom legend
    n_celltypes == 3 ~ c(8, 5.5), # 3: bottom legend
    n_celltypes <= 5 ~ c(9, 6), # 4 & 5: inset legend
    n_celltypes <= 6 ~ c(8, 7.5), # 6: bottom legend
    .default = c(9, 9) # 7 & 8: inset legend
  )
}
```


The plots and tables included here detail the results from performing cell type annotation.

```{r, eval = !is_supplemental, results = 'asis'}
cellassign_not_run <- check_cellassign_not_run(
  has_cellassign,
  colData(processed_sce)
)

# define bullets glue string
methods_bullets <- c(
  ifelse(has_submitter, "Submitter-provided", NA),
  ifelse(has_consensus, "Consensus cell types", NA),
  ifelse(has_singler, "`SingleR`", NA),
  ifelse(has_cellassign, "`CellAssign`", NA)
) |>
  na.omit() |>
  # make it bullets
  stringr::str_replace_all("^", "* ") |>
  stringr::str_flatten(collapse = "\n")



# print the bullets and other info messages
glue::glue("
  This library contains the following cell type annotations:

  {methods_bullets}
")

if (cellassign_not_run) {
  glue::glue(
    "\n\nCell type annotation with `CellAssign` was attempted but not run due to an insufficient number of cells."
  )
}

if (has_consensus) {
  glue::glue(
    "\n\nConsensus cell types are obtained based on agreement between `SingleR` and `CellAssign` using an ontology-aware approach.
If no common label is identified, no consensus cell type is assigned.
See the [ScPCA Portal documentation](https://scpca.readthedocs.io/en/stable/processing_information.html#cell-type-annotation) for a full description on how these cell type annotations are assigned.
`SingleR` and `CellAssign` annotation results are provided in the [supplementary cell type QC report](`r params$celltype_report`)."
  )
}

glue::glue("
  \n\nFor additional information about cell typing, including the results from all methods used, information about reference sources, comparisons among cell type annotation methods, and diagnostic plots, please refer to the [supplementary cell type QC report](`r params$celltype_report`).
")
```


## Statistics

```{r, warning = FALSE}
# Create data frame of cell types
celltype_df <- create_celltype_df(processed_sce)

# determine UMAP point sizing
umap_points_sizes <- determine_umap_point_size(ncol(processed_sce))
umap_point_size <- umap_points_sizes[1]
umap_facet_point_size <- umap_points_sizes[2]
```


```{r, eval = (has_cellassign || has_singler) && (is_supplemental || !has_consensus), results='asis'}
unclassified_methods <- c()

# check for unclassified SingleR cells
if (has_singler && any(celltype_df$singler_celltype_annotation == "Unclassified cell")) {
  unclassified_methods <- c(unclassified_methods, "SingleR")

  # remove all unclassified cells
  celltype_df <- celltype_df |>
    dplyr::filter(
      singler_celltype_annotation != "Unclassified cell"
    ) |>
    dplyr::mutate(
      singler_celltype_annotation = forcats::fct_drop(
        singler_celltype_annotation,
        only = "Unclassified cell"
      )
    )
}

# check for unclassified cellassign cells
if (has_cellassign && any(celltype_df$cellassign_celltype_annotation == "Unclassified cell")) {
  unclassified_methods <- c(unclassified_methods, "CellAssign")

  # remove unclassified cells
  celltype_df <- celltype_df |>
    dplyr::filter(
      cellassign_celltype_annotation != "Unclassified cell"
    ) |>
    dplyr::mutate(
      cellassign_celltype_annotation = forcats::fct_drop(
        cellassign_celltype_annotation,
        only = "Unclassified cell"
      )
    )
}

# print a warning if either singleR or cellAssign have any unclassified cells
if (length(unclassified_methods) > 0) {
  unclassified_methods <- stringr::str_flatten_comma(unclassified_methods, last = ", and ")
  glue::glue("
 <div class=\"alert alert-info\">

  When reprocessing this library, old results from running {unclassified_methods} were used.
  This means results were calculated with a slightly different set of cells.
  Any cells that are missing have been annotated as `Unclassified cell` in the object and will not be shown in any plots.

  </div>
")
}
```


```{r, eval = has_submitter}
knitr::asis_output('
### Submitter-provided cell type annotations\n

In this table, cells labeled "Submitter-excluded" are those for which submitters did not provide an annotation.
')
create_celltype_n_table(celltype_df, submitter_celltype_annotation) |>
  format_celltype_n_table()
```

```{r, eval = has_consensus}
knitr::asis_output('### Consensus cell type annotations\n

In this table, cells labeled "Unknown cell type" are those whose `SingleR` and `CellAssign` annotations did not agree.
In the processed result files, these cells are labeled `Unknown`.
')
create_celltype_n_table(celltype_df, consensus_celltype_annotation) |>
  format_celltype_n_table()
```

```{r, eval = has_singler && (!has_consensus || is_supplemental)}
knitr::asis_output('### `SingleR` cell type annotations\n

In this table, cells labeled "Unknown cell type" are those which `SingleR` pruned due to low-quality assignments.
In the processed result files, these cells are labeled `NA`.
')
create_celltype_n_table(celltype_df, singler_celltype_annotation) |>
  format_celltype_n_table()
```

```{r, eval = has_cellassign && (!has_consensus || is_supplemental)}
knitr::asis_output('### `CellAssign` cell type annotations\n

In this table, cells labeled "Unknown cell type" are those which `CellAssign` could not confidently assign to a label in the reference list.
In the processed result files, these cells are labeled `"other"`.
')
create_celltype_n_table(celltype_df, cellassign_celltype_annotation) |>
  format_celltype_n_table()
```


```{r, eval = has_umap, warning = FALSE}
# Create dataset for plotting UMAPs with lumped and label-wrapped cell types
umap_df <- lump_wrap_celltypes(celltype_df)
```

```{r, eval = has_umap && has_celltypes }
# only mention multiple annotations if we're actually showing multiple annotations
if (has_consensus && !has_submitter && !is_supplemental) {
  umap_text <- ""
} else {
  umap_text <- "For each cell typing method, we show a separate faceted UMAP."
}


knitr::asis_output(glue::glue(
  '## UMAPs

  In this section, we show UMAPs colored by cell types.
  {umap_text}
In each panel, cells that were assigned the given cell type label are colored, while all other cells are in grey.

For legibility, only the seven most common cell types are shown.
All other cell types are grouped together and labeled "All remaining cell types" (not to be confused with "Unknown cell type" which represents cells that could not be classified).
  '
))
```

<!-- Now, UMAPs of cell types, where present -->

```{r}
if (has_submitter & has_umap) {
  submitter_n_celltypes <- length(levels(umap_df$submitter_celltype_annotation_lumped))
  submitter_dims <- determine_umap_dimensions(submitter_n_celltypes)
} else {
  # set fake dims for evaluating next chunk
  submitter_dims <- c(1, 1)
}
```

```{r, eval = has_submitter && has_umap, message=FALSE, warning=FALSE, fig.width = submitter_dims[1], fig.height = submitter_dims[2], fig.align = "center"}
# umap for cell assign annotations
faceted_umap(
  umap_df,
  submitter_n_celltypes,
  submitter_celltype_annotation_lumped,
  point_size = umap_facet_point_size
) +
  ggtitle("UMAP colored by submitter-provided annotations")
```


```{r}
if (has_consensus & has_umap) {
  consensus_n_celltypes <- length(levels(umap_df$consensus_celltype_annotation_lumped))
  consensus_dims <- determine_umap_dimensions(consensus_n_celltypes)
} else {
  # set fake dims for evaluating next chunk
  consensus_dims <- c(1, 1)
}
```


```{r, eval=has_consensus && has_umap, message=FALSE, warning=FALSE, fig.width = consensus_dims[1], fig.height = consensus_dims[2], fig.align = "center"}
# umap for cell assign annotations
faceted_umap(
  umap_df,
  consensus_n_celltypes,
  consensus_celltype_annotation_lumped,
  point_size = umap_facet_point_size
) +
  ggtitle("UMAP colored by consensus cell type annotations")
```

```{r}
if (has_singler & has_umap) {
  singler_n_celltypes <- length(levels(umap_df$singler_celltype_annotation_lumped))
  singler_dims <- determine_umap_dimensions(singler_n_celltypes)
} else {
  # set fake dims for evaluating next chunk
  singler_dims <- c(1, 1)
}
```


```{r, eval=has_singler && has_umap && (is_supplemental || !has_consensus), message=FALSE, warning=FALSE, fig.width = singler_dims[1], fig.height = singler_dims[2], fig.align = "center"}
# umap for cell assign annotations
faceted_umap(
  umap_df,
  singler_n_celltypes,
  singler_celltype_annotation_lumped,
  point_size = umap_facet_point_size
) +
  ggtitle("UMAP colored by SingleR annotations")
```


```{r}
if (has_cellassign & has_umap) {
  cellassign_n_celltypes <- length(levels(umap_df$cellassign_celltype_annotation_lumped))
  cellassign_dims <- determine_umap_dimensions(cellassign_n_celltypes)
} else {
  # set fake dims for evaluating next chunk
  cellassign_dims <- c(1, 1)
}
```

```{r, eval = has_cellassign && has_umap && (is_supplemental || !has_consensus), message=FALSE, warning=FALSE, fig.width = cellassign_dims[1], fig.height = cellassign_dims[2], fig.align = "center"}
# umap for cell assign annotations
faceted_umap(
  umap_df,
  cellassign_n_celltypes,
  cellassign_celltype_annotation_lumped,
  point_size = umap_facet_point_size
) +
  ggtitle("UMAP colored by CellAssign annotations")
```


```{r, eval=has_consensus}
knitr::asis_output("
## Expression of marker genes in consensus cell types

This section looks at expression of a set of marker genes for each consensus cell type across all cells.
Consensus cell types are grouped into a broader cell type category for validation, e.g., all types of T cell will be grouped together as T cells.

The dot plot shows the mean expression and percent of cells expressing the marker gene for cells from each broad cell type group.
The y-axis includes marker genes for each cell type.
Marker genes were obtained from the list of Human cell markers on [`CellMarker2.0`](http://www.bio-bigdata.center/CellMarker_download.html).
All marker genes shown are specific to a single cell type, with the exception of hematopoietic precursor cells, if present, which express genes found in other, more differentiated immune cells.

We expect that each cell type group should show high expression of marker genes associated with that cell type compared to all other cells in the dataset.

Note that dots are only shown if the gene has mean expression greater than 0 and is expressed in at least 10% of the cells in the given cell type.

If all consensus cell types are labeled as `Unknown cell type`, then no dot plot will be shown. 
  ")
```


```{r, eval=has_consensus, message=FALSE,warning=FALSE}
# validation groups and marker gene table info
validation_groups_df <- validation_groups_df |>
  # rename final assigned group to avoid conflicts when merging in marker gene expression
  # we want to separate the marker gene group from the actual cell type annotation
  dplyr::select(consensus_annotation, broad_celltype_group = validation_group_annotation)

# read in validation markers
markers_df <- validation_markers_df |>
  # only keep genes unique to a single cell type except HPC which doesn't have any unique genes
  # for HPC we keep all 6 marker genes
  dplyr::filter(gene_observed_count == 1 | validation_group_annotation == "hematopoietic precursor cell")

# define color palette
celltype_colors <- celltype_colors_df |>
  tibble::deframe()
```


```{r, eval = has_consensus}
# extract gene expression for marker genes from SCE
# list of all marker genes
all_markers <- markers_df |>
  dplyr::pull(ensembl_gene_id) |>
  unique()

# we only care about if that gene is expressed otherwise we won't waste memory and include it
expressed_genes <- rowData(processed_sce) |>
  as.data.frame() |>
  dplyr::filter(detected > 0) |>
  dplyr::pull(gene_ids)

# get markers that are expressed
expressed_markers <- intersect(all_markers, expressed_genes)

# get logcounts from sce for expressed genes
gene_exp_df <- scuttle::makePerCellDF(
  processed_sce,
  features = expressed_markers,
  assay.type = "logcounts",
  use.coldata = "barcodes",
  use.dimred = FALSE
) |>
  tidyr::pivot_longer(starts_with("ENSG"), names_to = "ensembl_gene_id", values_to = "logcounts") |>
  dplyr::mutate(
    detected = logcounts > 0,
    unique_id = params$unique_id
  )

# Join all consensus results and marker gene info
consensus_df <- celltype_df |>
  dplyr::select(barcodes, consensus_celltype_annotation) |>
  dplyr::left_join(validation_groups_df, by = c("consensus_celltype_annotation" = "consensus_annotation")) |>
  dplyr::left_join(gene_exp_df, by = c("barcodes")) |>
  # add marker gene information (associated validation group annotation, gene observed count, percent tissues)
  # account for the same gene being present in multiple cell types
  dplyr::left_join(markers_df, by = "ensembl_gene_id", relationship = "many-to-many") |>
  dplyr::mutate(
    broad_celltype_group = dplyr::if_else(
      is.na(broad_celltype_group),
      "unknown",
      broad_celltype_group
    )
  )
```

```{r, eval = has_consensus}
# prep for plots
# get total number of cells per final annotation group
total_cells_df <- consensus_df |>
  dplyr::select(barcodes, broad_celltype_group) |>
  dplyr::distinct() |>
  dplyr::count(broad_celltype_group, name = "total_cells")

# table with one row per unique broad cell type/ marker gene combination
# first all cells in with the same broad_celltype_group (determined based on consensus_annotation) are grouped together
# then get the mean gene expression and total percentage of cells that express each marker gene across all cells in that group
# do this for every possible marker gene/ validation group assignment
# second we calculate the mean expression and mean percentage of all marker genes in a given validation group (this value is used only in the second section of the report)
group_stats_df <- consensus_df |>
  # for each assigned cell type/marker gene combo get total detected and mean expression
  # group by both broad group and validation group to account for genes that are expressed in more than one cell type
  dplyr::summarize(
    .by = c("broad_celltype_group", "ensembl_gene_id", "validation_group_annotation"),
    detected_count = sum(detected),
    mean_exp = mean(logcounts)
  ) |>
  # add in validation group for marker genes
  # this includes all possible marker genes and all possible validation group assignments
  dplyr::left_join(markers_df, by = c("ensembl_gene_id", "validation_group_annotation"), relationship = "many-to-many") |> # add total cells
  dplyr::left_join(total_cells_df, by = c("broad_celltype_group")) |>
  dplyr::mutate(
    # get total percent expressed
    percent_exp = (detected_count / total_cells) * 100,
    # account for NA/unknowns and set axes order
    broad_celltype_group = factor(broad_celltype_group, levels = c(names(celltype_colors)))
  )

# get list of celltypes to keep and assign colors
celltype_groups <- group_stats_df |>
  dplyr::pull(broad_celltype_group) |>
  unique() |>
  as.character()

# filter markers to those that are actually relevant
# we will only plot the marker genes for cell types that are part of the assigned broad validation group for this group of samples
# we don't care about plotting marker genes for cell types that aren't present here
filtered_markers_df <- markers_df |>
  dplyr::filter(
    validation_group_annotation %in% celltype_groups,
    gene_symbol %in% group_stats_df$gene_symbol
  ) |>
  # ensure order matches the order of the legend
  dplyr::mutate(
    validation_group_annotation = factor(validation_group_annotation, levels = names(celltype_colors))
  ) |>
  dplyr::arrange(validation_group_annotation)

# specify x axis order for dotplot
marker_gene_order <- filtered_markers_df |>
  dplyr::pull(gene_symbol)

# set order for cell types
celltype_order <- unique(filtered_markers_df$validation_group_annotation)

# filter out low expressed genes
dotplot_df <- group_stats_df |>
  dplyr::filter(mean_exp > 0, percent_exp > 10) |>
  dplyr::arrange(broad_celltype_group) |>
  # add a label for the plot
  dplyr::mutate(y_label = glue::glue("{broad_celltype_group} ({total_cells})")) |>
  # remove marker genes that aren't present in final annotations and set x axis order
  dplyr::filter(gene_symbol %in% marker_gene_order) |>
  dplyr::mutate(
    # set orders of gene symbol and validation groups
    y_label = factor(y_label, levels = rev(unique(y_label))),
    gene_symbol = factor(gene_symbol, levels = marker_gene_order),
    validation_group_annotation = factor(validation_group_annotation, levels = celltype_order)
  )
```


```{r, eval = has_consensus, fig.height=7, fig.width=15}
# only make a dot plot if we have at least one validation group annotation present 
if(length(unique(dotplot_df$validation_group_annotation)) > 0) {
  
  # make dotplot with marker gene exp
  dotplot <- ggplot(dotplot_df, aes(y = y_label, x = gene_symbol, color = mean_exp, size = percent_exp)) +
    geom_point() +
    scale_color_viridis_c(option = "magma") +
    facet_grid(cols = vars(validation_group_annotation), scales = "free", space = "free") +
    theme_classic() +
    theme(
      strip.background = element_rect(fill = "transparent", color = NA),
      strip.placement = "outside",
      strip.text.x = element_blank(),
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
      axis.ticks.x = element_blank(),
      text = element_text(size = 14),
      panel.spacing = unit(0.5, "lines") # adjust spacing and match with annotation bar
    ) +
    labs(
      x = "",
      y = "Broad cell type annotation",
      color = "Mean gene expression",
      size = "Percent cells expressed"
    )
  
  
  # add annotation bar aligning marker genes with validation group
  color_bar <- ggplot(dotplot_df, aes(x = gene_symbol, y = 1, fill = validation_group_annotation)) +
    geom_tile() +
    facet_grid(cols = vars(validation_group_annotation), scales = "free", space = "free") +
    scale_fill_manual(values = celltype_colors, breaks = levels(dotplot_df$validation_group_annotation)) +
    ggmap::theme_nothing() +
    theme(
      strip.background = element_rect(fill = "transparent", color = NA),
      strip.text.x = element_text(angle = 90, hjust = 0, vjust = 0.5, size = 12),
      strip.placement = "outside",
      legend.position = "none",
      panel.spacing = unit(0.5, "lines"),
      strip.clip = "off"
    ) +
    labs(fill = "")
  
  combined_plot <- color_bar / dotplot +
    patchwork::plot_layout(ncol = 1, heights = c(0.1, 4))
  
  combined_plot
}
```


```{r}
# boolean for whether or not to include submitter heatmaps
submitter_heatmaps <- (has_submitter & (has_consensus | has_cellassign | has_singler))
```

```{r, eval=submitter_heatmaps | has_consensus, results = 'asis'}
# update text depending on if this is the main or supplemental report
if (has_submitter & has_consensus & !is_supplemental) {
  heatmap_text <- "This section displays heatmaps comparing consensus cell type labels to submitter annotations."
} else {
  heatmap_text <- "This section displays heatmaps comparing cell labels from various methods."
}

glue::glue(
  "
  # Cell label comparisons

  {heatmap_text}

  We use the [Jaccard similarity index](https://en.wikipedia.org/wiki/Jaccard_index) to display the agreement between between         pairs of labels assigned by different annotation methods.

  The Jaccard index reflects the degree of overlap between the two labels and ranges from 0 to 1.

  * If the labels are assigned to identical sets of cells, the Jaccard index will be 1.
  * If the labels are assigned to completely non-overlapping sets of cells, the Jaccard index will be 0.

  High agreement between methods qualitatively indicates higher confidence in the cell type annotation.

"
)
```

```{r}
if (has_submitter & has_consensus & !is_supplemental) {
  # Set plot dimensions based on number of consensus cell types
  all_celltypes <- levels(celltype_df$consensus_celltype_annotation)
  plot_height <- calculate_plot_height(
    unique(celltype_df$consensus_celltype_annotation),
    unique(celltype_df$submitter_celltype_annotation),
    0
  )
} else {
  # set a default to avoid failure in the next chunk
  plot_height <- 1
}
```


```{r, eval = has_submitter & has_consensus & !is_supplemental, fig.height = plot_height, fig.width = 8.5}
# Calculate jaccard matrix
consensus_submitter_matrix <- make_jaccard_matrix(
  celltype_df,
  "submitter_celltype_annotation",
  "consensus_celltype_annotation"
)

create_single_heatmap(
  consensus_submitter_matrix,
  row_title = "Consensus cell types",
  column_title = "Submitter-provided annotations",
  labels_font_size = find_label_size(all_celltypes),
  keep_legend_name = "Consensus cell types",
  col_fun = heatmap_col_fun,
  # additional arguments
  column_names_rot = 90
) |>
  ComplexHeatmap::draw(
    heatmap_legend_side = "bottom"
  )
```
