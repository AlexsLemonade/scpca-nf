# Cell type Annotation Summary


```{r}
## function definitions ##

#' Create tables of cell type annotation counts
#'
#' @param df Data frame with cell types
#' @param celltype_column Column with cell type annotations, not a string.
#'
#' @return table with cell type counts
create_celltype_n_table <- function(df, celltype_column) {
  df |>
    dplyr::count({{ celltype_column }}) |>
    # Add percentage column
    dplyr::mutate(
      `Percent of cells` = paste0(round(n / sum(n) * 100, digits = 2), "%")
    ) |>
    # set column order & rename
    dplyr::select(
      `Annotated cell type` = {{ celltype_column }},
      `Number of cells` = n,
      `Percent of cells`
    )
}

#' Format tables of cell type counts as kable
#'
#' @param df Data frame to format
#'
#' @return kable table of cell type counts
format_celltype_n_table <- function(df) {
  df |>
    knitr::kable(align = "r") |>
    kableExtra::kable_styling(
      bootstrap_options = "striped",
      full_width = FALSE,
      position = "left"
    ) |>
    kableExtra::column_spec(2, monospace = TRUE)
}

#' Function to lump celltype columns in an existing data frame for all of the
#'  following columns, if they exist: `<singler/cellassign/submitter>_celltype_annotation`.
#'  The resulting lumped column will be named:
#'  `<singler/cellassign/submitter>_celltype_annotation_lumped`.
#'
#'
#' @param df Data frame to manipulate
#' @param n_celltypes Number of groups to lump into, with rest put into "Other" group. Default is 7.
#'
#' @return Updated df with new column of lumped celltypes for each present method
lump_celltypes <- function(df, n_celltypes = 7) {

  # Update the df for each of the following, if present
  methods <- c("singler", "cellassign", "submitter")
  df <- df |>
    dplyr::mutate(
      across(
        ends_with("_celltype_annotation"),
        \(x) forcats::fct_lump_n(x, n_celltypes, other_level = "All remaining cell types"),
        .names = "{.col}_lumped"
      )
    )

  return(df)
}





#' Make UMAP  colored by given variable
#'
#' @param umap_df Data frame with UMAP1 and UMAP2 columns
#' @param color_variable Column in data frame to color by, not a string.
#' @param legend_title Title for legend.
#' @param legend_nrow Number of rows in legend. Default is 2.
#'
#' @return UMAP plot as a ggplot2 object
plot_umap <- function(
  umap_df,
  color_variable,
  legend_title,
  legend_nrow = 2
){
  ggplot(umap_df) +
    aes(
      x = UMAP1,
      y = UMAP2,
      color = {{ color_variable }}
    ) +
    geom_point(
      size = 0.3,
      alpha = 0.5
    ) +
    # remove axis numbers and background grid
    scale_x_continuous(labels = NULL, breaks = NULL) +
    scale_y_continuous(labels = NULL, breaks = NULL) +
    coord_fixed() +
    guides(
      color = guide_legend(
        title = legend_title,
        nrow = legend_nrow,
        # more visible points in legend
        override.aes = list(
          alpha = 1,
          size = 1.5
        )
      )
    ) +
    theme(legend.position = "bottom")
}

```

<!-- Background depends on which cell types are present in the SCE. -->

The plots and tables included here detail the results from performing cell type annotation.
Cell type annotations were obtained in the following way(s): 

<!-- Submitter -->
```{r, eval = has_submitter, results='asis'}
glue::glue(
  "* Cell type annotations were provided by the original lab (`submitter-provided`) which generated this data.
  "
)
```


```{r, eval = has_singler, results='asis'}
glue::glue(
  "* Cell types were annotated using [`SingleR`](https://bioconductor.org/packages/release/bioc/html/SingleR.html), which uses a reference-based approach ([Looney _et al._ 2019](https://doi.org/10.1038/s41590-018-0276-y)).
  The `{metadata(processed_sce)$singler_reference}` reference dataset, obtained from the [`celldex` package](http://bioconductor.org/packages/release/data/experiment/html/celldex.html), was used for cell typing."
)
```


```{r, eval = has_cellassign, results='asis'}
tissue_type <- stringr::word(
  metadata(processed_sce)$cellassign_reference,
  -1,
  sep = "-"
)

glue::glue(
  "* Cell types were annotated using [`CellAssign`](https://github.com/Irrationone/cellassign), which uses a marker-gene based approach ([Zhang _et al._ 2019](https://doi.org/10.1038/s41592-019-0529-1)).
  Marker genes associated with `{tissue_type}` tissue were obtained from [PanglaoDB](https://panglaodb.se/).
  "
)
```


<!-- At least one cell type annotation method required for the supplemental report -->
```{r, eval = has_singler | has_cellassign, results='asis'}
glue::glue("
  For additional information about cell typing, including diagnostic plots and/or heatmap comparisons among annotations (if available), please refer to the [supplementary cell type QC report](`r params$celltype_report`).
 ")
```


## Statistics

```{r}
# Create data frame of cell types
celltype_df <- create_celltype_df(processed_sce)
```


```{r, eval = has_submitter}
knitr::asis_output('
### Submitter-provided cell type annotations\n

In this table, cells labeled "Unclassified cell" are those for which submitters did not provide an annotation.
')
create_celltype_n_table(celltype_df, submitter_celltype_annotation) |>
  format_celltype_n_table()
```

```{r, eval = has_singler}
knitr::asis_output('### `SingleR` cell type annotations\n

In this table, cells labeled as "Unknown cell type" are those which `SingleR` could not confidently identify.
')
create_celltype_n_table(celltype_df, singler_celltype_annotation) |>
  format_celltype_n_table()
```

```{r, eval = has_cellassign}
knitr::asis_output('### `CellAssign` cell type annotations\n

In this table, cells labeled as "Unknown cell type" are those which `CellAssign` could not confidently identify.
')
create_celltype_n_table(celltype_df, cellassign_celltype_annotation) |>
  format_celltype_n_table()
```

## UMAPs

In this section, we show UMAPs colored by clusters. 
Clusters were calculated using the graph-based `r metadata(processed_sce)$cluster_algorithm` algorithm with `r metadata(processed_sce)$cluster_weighting` weighting.


```{r}
# Create dataset for plotting UMAPs with lumped cell types
umap_df <- lump_celltypes(celltype_df)
```


<!-- First UMAP: clusters -->
```{r message=FALSE, warning=FALSE}
clusters_plot <- plot_umap(
  umap_df,
  cluster,
  "Cluster"
) +
  ggtitle("UMAP colored by cluster identity")

# Determine palette based on number of levels.
# If we have <=8, we can use a CVD-friendly palette (they generally don't have more than 8 colors).
#  Otherwise, we will use the default palette.
if (length(levels(umap_df$cluster)) <= 8) {
  clusters_plot +
    scale_color_brewer(palette = "Set2")
} else {
  clusters_plot
}
```


Next, we show UMAPs colored by cell types.
A separate UMAP is shown for each cell typing method used.

For legibility, only the seven most common cell types are shown.
All other cell types are grouped together and labeled "All remaining cell types" (not to be confused with "Unknown cell type" or "Unclassified cell", which represent cells that could not be classified).

<!-- Now, UMAPs of cell types, where present -->

```{r eval = has_submitter, message=FALSE, warning=FALSE}
plot_umap(umap_df,
  submitter_celltype_annotation_lumped,
  "Cell types",
  legend_nrow = 4
) +
  ggtitle("UMAP colored by submitter-provided annotations") +
  scale_color_brewer(palette = "Dark2")
```


```{r eval=has_singler, message=FALSE, warning=FALSE}
plot_umap(umap_df,
  singler_celltype_annotation_lumped,
  "Cell types",
  legend_nrow = 4
) +
  ggtitle("UMAP colored by SingleR annotations") +
  scale_color_brewer(palette = "Dark2")
```


```{r, eval = has_cellassign, message=FALSE, warning=FALSE}
plot_umap(umap_df,
  cellassign_celltype_annotation_lumped,
  "Cell types",
  legend_nrow = 4
) +
  ggtitle("UMAP colored by CellAssign annotations") +
  scale_color_brewer(palette = "Dark2")
```
