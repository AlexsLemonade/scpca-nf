# Cell type Annotation Summary

This section details results from performing cell type annotation.
The following method(s) were used to perform cell typing:

<!-- Background depends on which cell type methods were used -->

```{r, eval = has_singler}
knitr::asis_output(
  glue::glue(
  "* [`SingleR`](https://bioconductor.org/packages/release/bioc/html/SingleR.html), which uses a reference-based approach.
  The `{metadata(processed_sce)$singler_reference}` reference dataset, obtained from the [`celldex` package](http://bioconductor.org/packages/release/data/experiment/html/celldex.html) package, was used for cell typing."
  )
)
```


```{r, eval = has_cellassign}
knitr::asis_output(
  glue::glue(
  "
  * [`CellAssign`](https://github.com/Irrationone/cellassign), which uses a marker-gene based approach.
  Marker genes associated with `{metadata(processed_sce)$cellassign_reference}` tissue were obtained from [PanglaoDB](https://panglaodb.se/).
  ")
)
```


Cells annotated as "Unknown cell type" represent cells which could not be confidently identified using the given annotation method. 

If available, these results will be compared to cell type annotations provided by the data's originating research group ("submitter-provided cell type annotations".)

## Cell type Annotation Statistics

```{r}
# This chunk defines a helper function to reformat annotations:
#  * Annotations that are `NA`/"other" are changed to "Unknown cell type" 
#  * Annotations are converted to a factor ordered by frequency, but with 
#    "Unknown cell type" always last.
prepare_annotation_values <- function(df, annotation_column) {
  df |>
    dplyr::mutate(
      {{annotation_column}} := dplyr::case_when(
        # singler condition
        is.na({{annotation_column}}) ~ "Unknown cell type",
        # cellassign conditon
        {{annotation_column}} == "other" ~ "Unknown cell type",
        # otherwise, keep it
        TRUE ~ {{annotation_column}}
        
      ),
      {{annotation_column}} := forcats::fct_infreq({{annotation_column}}),
      {{annotation_column}} := forcats::fct_relevel({{annotation_column}},
                                                    "Unknown cell type",
                                                    after = Inf)
    )
}
```

```{r}
# Create data frame of cell types
celltype_df <- colData(processed_sce) |>
  as.data.frame() |>
  # barcodes to a column
  tibble::rownames_to_column(var = "barcode") |>
  # keep only cell name, celltyping, and clusters
  dplyr::select(barcode, 
                clusters,
                contains("singler"),
                contains("cellassign"))



if (has_singler) {
  celltype_df <- celltype_df |>
    prepare_annotation_values(singler_celltype_annotation)
}
if (has_cellassign) {
  celltype_df <- celltype_df |>
    prepare_annotation_values(cellassign_celltype_annotation)
} 
    
# Define a helper function to create tables for singler and cellassign annotations
create_celltype_n_table <- function(df, celltype_column) {
  df |>
    dplyr::count({{celltype_column}}) |>
    # Add percentage column
    dplyr::mutate(
      `Percent of cells` =  paste0(round(n/sum(n) * 100, digits = 2), "%")
    ) |>
    # set column order & rename
    dplyr::select(
      `Annotated cell type` = {{celltype_column}},
      `Number of cells` = n,
      `Percent of cells`
    ) |>
    # kable formatting
    knitr::kable(align = 'r') |>
    kableExtra::kable_styling(bootstrap_options = "striped",
                             full_width = FALSE,
                             position = "left") |>
    kableExtra::column_spec(2, monospace = TRUE)
}
```



```{r, eval = has_singler}
knitr::asis_output("### `SingleR` cell type annotations\n")
create_celltype_n_table(celltype_df, singler_celltype_annotation)
```

```{r, eval = has_cellassign}
knitr::asis_output("### `CellAssign` cell type annotations\n")
create_celltype_n_table(celltype_df, cellassign_celltype_annotation)
```

```{r, eval = has_submitter_celltypes}
knitr::asis_output("### Submitter-provided cell type annotations\n")
# Note: submitter annotations have not yet been added to the workflow, 
#  so this variable name `submitter_celltype_annotation` is just a placeholder
create_celltype_n_table(celltype_df, submitter_celltype_annotation)
```


## Cell type Annotation Assessment

In this section, we assess the reliability of cell type annotations using diagnostic plots.


```{r, eval = has_singler, warning=FALSE, fig.height = 6, fig.width = 9}
knitr::asis_output("
### `SingleR` assessment

`SingleR` assigns cell types using on score based on Spearman correlations across features in the reference dataset.
We evaluate the reliability of cell type annotations using the per-cell _delta median_ statistic, which is the difference between the score for the cell's assigned label and the median score of all labels for the given cell.
Higher _delta median_ values indicate more confidence in the cell type annotation.
For more information, refer to the [`Singler` book section on 'Annotation diagnostics'](https://bioconductor.org/packages/release/bioc/vignettes/SingleR/inst/doc/SingleR.html#4_Annotation_diagnostics).

In the plot, each black point corresponds to the _delta median_ statistic a cell with the given cell type annotation. 
The red points with error bars represent the median Â± interquartile range (IQR).
")

# Prepare SingleR scores for plot

# extract scores into matrix
singler_scores <- metadata(processed_sce)$singler_result$scores |>
  as.matrix()


# Create data frame for plotting with delta median and wrapped levels
 delta_median_df <- celltype_df |>
  dplyr::mutate(
    delta_median = rowMaxs(singler_scores) - rowMedians(singler_scores)
  )

delta_median_df$annotation_wrapped <- factor(
  delta_median_df$singler_celltype_annotation,
  levels = levels(delta_median_df$singler_celltype_annotation),
  labels = stringr::str_wrap(levels(celltype_df$singler_celltype_annotation), 30)
)
 
# Plot the scores across celltypes
ggplot(delta_median_df) + 
  aes(x = annotation_wrapped, y = delta_median) + 
  ggforce::geom_sina(size = 0.2, 
                     alpha = 0.5) +
    stat_summary(
      color = "red",
      # median and quartiles for point range
      fun = "median",
      fun.min = function(x) {
        quantile(x, 0.25)
      },
      fun.max = function(x) {
        quantile(x, 0.75)
      },
      geom = "pointrange",
      position = position_dodge(width = 0.9),
      size = 0.1
    ) + 
  labs(
    x = "Cell type annotation",
    y = "Delta median statistic"
  ) + 
  theme(
    axis.text.x = element_text(angle = 55, hjust = 1)
  )
```


## Cell type Annotations and Clusters


### UMAPs

In this section, we show UMAPs colored by clusters and cell types.
A separate UMAP is shown for each cell typing method used.
Clusters were calculated using the graph-based `r metadata(processed_sce)$cluster_algorithm` algorithm with `r metadata(processed_sce)$cluster_weighting` weights.

For legibility, only the seven most common cell types are shown.
All other cell types are grouped together and labeled "Other cell type" (not to be confused with "Unknown cell types," which represent cells that could not be classified).


```{r}
# Create dataset for plotting UMAPs with lumped cell types
umap_df <- tibble::tibble(
  UMAP1 = unname(reducedDim(processed_sce, "UMAP")[,1]),
  UMAP2 = unname(reducedDim(processed_sce, "UMAP")[,2]),
  clusters = processed_sce$clusters
)

# helper function for lumping cell types
lump_celltypes <- function(umap_df, 
                           celltype_df,
                           celltype_method,
                           n_celltypes = 7) {
  
  umap_df |>
    dplyr::mutate(
      celltypes =  celltype_df[[glue::glue("{celltype_method}_celltype_annotation")]],
      celltypes = forcats::fct_lump_n(celltypes,
                                      n_celltypes, 
                                      other_level = "Other cell type")) |>
    # finally, rename temporary `celltypes` column to the provided method
    dplyr::rename({{celltype_method}} := celltypes)
}

if (has_singler) {
  umap_df <- lump_celltypes(umap_df, celltype_df, "singler")
}
if (has_cellassign) {
  umap_df <- lump_celltypes(umap_df, celltype_df, "cellassign")
}
# Note that later, we will want to do this with submitter cell types too, if present.
```


```{r}
# Define helper function for making UMAPs in this section
#  this function uses the default palette, which can be customized when
#  calling the function
plot_umap <- function(umap_df, 
                      color_variable,
                      legend_title, 
                      legend_nrow = 2) {
  
  ggplot(umap_df) + 
    aes(x = UMAP1, 
        y = UMAP2, 
        color = {{color_variable}}) + 
    geom_point(size = 0.3,
               alpha = 0.5) + 
    # remove axis numbers and background grid
    scale_x_continuous(labels = NULL, breaks = NULL) + 
    scale_y_continuous(labels = NULL, breaks = NULL) + 
    coord_fixed() + 
    guides(
      color = guide_legend(title = legend_title, 
                           nrow = legend_nrow,
                           # more visible points in legend
                           override.aes = list(alpha = 1,
                                               size = 1.5))) + 
    theme(legend.position = "bottom")
}
```

<!-- First UMAP: clusters --> 
```{r message=FALSE, warning=FALSE}
clusters_plot <- plot_umap(umap_df, 
          clusters,
          "Clusters") +
  ggtitle("UMAP colored by clusters")

# Determine palette based on number of levels.
# If we have <=8, we can use a CVD-friendly palette (they generally don't have more than 8 colors). 
#  Otherwise, we will use the default palette.
if (length(levels(umap_df$clusters)) <= 8) {
  clusters_plot + 
    scale_color_brewer(palette =  "Set2")
} else {
  clusters_plot
}
  
```

<!-- Now, UMAPs of cell types, where present -->

```{r eval=has_singler, message=FALSE, warning=FALSE}
plot_umap(umap_df, 
          singler,
          "Cell types",
          legend_nrow = 4) +
  ggtitle("UMAP colored by SingleR annotations") + 
  scale_color_brewer(palette = "Dark2")
```


```{r, eval = has_cellassign, message=FALSE, warning=FALSE}
plot_umap(umap_df, 
          cellassign,
          "Cell types",
          legend_nrow = 4) +
  ggtitle("UMAP colored by CellAssign annotations")  + 
  scale_color_brewer(palette = "Dark2")
```


```{r eval=has_submitter_celltypes, message=FALSE, warning=FALSE}
# Nothing in this chunk yet - it's a placeholder
```

### Heatmaps

Below, we show heat maps comparing cell type annotations (along the y-axis) to clustering results (along the x-axis).
Heatmap colors represent the log number of cells present in both the given cell type and cluster.


```{r}
# Helper function for making a heatmap
create_celltype_heatmap <- function(x_vector,
                                    y_vector, 
                                    x_label = "",
                                    y_label = "", 
                                    column_names_rotation = 0,
                                    row_font_size = 8, 
                                    column_font_size = 10) {
  
  # build a matrix for making a heatmap
  celltype_mtx <- table(x_vector,
                        y_vector) |> 
    log1p() # log transform for visualization
    
  # Define CVD-friendly palette 
  heatmap_palette <- viridisLite::inferno(7, alpha = 1, begin = 0, end = 1, direction = 1)
  
  # heatmap
  heat <- ComplexHeatmap::Heatmap(celltype_mtx,
                                  # Overall heatmap parameters
                                  col = heatmap_palette,
                                  # Column parameters
                                  column_title = y_label,
                                  column_title_side = "bottom", 
                                  column_dend_side = "top",
                                  column_names_rot = column_names_rotation,
                                  column_names_gp = grid::gpar(fontsize = column_font_size),
                                  # Row parameters
                                  row_dend_side = "left",
                                  row_title_side = "right", 
                                  row_title = x_label,
                                  row_names_gp = grid::gpar(fontsize = row_font_size),
                                  # Legend parameters
                                  heatmap_legend_param = list(
                                    title = "Log(Number of cells)",
                                    title_position = "leftcenter-rot",
                                    legend_height = unit(4, "cm")
                                    )
                                  )
  # draw with legend on left for spacing
  ComplexHeatmap::draw(heat, heatmap_legend_side = "left")
}
```


```{r, eval = has_singler, fig.height=5, fig.width=7}
knitr::asis_output("### `SingleR` cluster and cell type heatmap\n")
create_celltype_heatmap(
  x_vector = celltype_df$singler_celltype_annotation, 
  y_vector = celltype_df$clusters, 
  y_label = "Clusters"
)
```

```{r, eval = has_cellassign, fig.height=5, fig.width=7}
knitr::asis_output("### `CellAssign` cluster and cell type heatmap\n")
create_celltype_heatmap(
  x_vector = celltype_df$cellassign_celltype_annotation, 
  y_vector = celltype_df$clusters, 
  y_label = "Clusters"
)
```

```{r, eval = has_submitter_celltypes, fig.height=5, fig.width=7}
knitr::asis_output("### Submitter-provided cluster and cell type heatmap\n")
create_celltype_heatmap(
  x_vector = celltype_df$submitter_celltype_annotation, 
  y_vector = celltype_df$clusters, 
  y_label = "Clusters"
)
```


<!-- Use large height/width to accommodate cell type labels --> 
```{r, eval = has_cellassign & has_singler, fig.height=7, fig.width=8}
knitr::asis_output("
## Cell Type Annotation Comparison

Below, we show a heatmap directly comparing `SingleR` and `CellAssign`cell type annotations.
Note that due to different annotations references, these methods may use different names for similar cell types.
")

create_celltype_heatmap(
  x_vector = celltype_df$singler_celltype_annotation, 
  y_vector = celltype_df$cellassign_celltype_annotation, 
  x_label = "SingleR annotations",
  y_label = "CellAssign annotations",
  column_names_rotation = 55,
  column_font_size = 8
)
```
