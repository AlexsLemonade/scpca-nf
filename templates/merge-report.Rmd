---
params:
  merge_group: "example_group"
  merged_sce: NULL
  batch_column: "library_id"

title: "`r glue::glue('ScPCA merged report for {params$merge_group}')`"
author: "Childhood Cancer Data Lab"
date: "`r params$date`"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
    number_sections: false
    code_download: true
---

```{r setup, message = FALSE, echo = FALSE}
# knitr options
knitr::opts_chunk$set(
  echo = FALSE
)

library(SingleCellExperiment)
library(ggplot2)

# Set default ggplot theme
theme_set(
  theme_bw() +
    theme(plot.margin = margin(rep(20, 4)))
)
```

```{r}
# check that input files are provided
if (is.null(params$merged_sce)) {
  stop("Must provide a merged SCE object.")
}

# define batch column
batch_column <- params$batch_column

# set adt/ multiplex values
has_adt <- "adt" %in% merged_sce$additional_modalities
is_multiplexed <- "cellhash" %in% merged_sce$additional_modalities
```

```{r, integration-warning, eval=FALSE}
glue::glue("
    <div class=\"alert alert-warning\">

    <b>CAUTION: The libraries included in the merged object are NOT integrated or batch-corrected.</b>

    </div>
  ")
```

```{r, ref.label=c('integration-warning'), eval=TRUE, results='asis'}
```


This report includes a brief summary of all libraries included in the merged object for `r params$merge_group`.
This merged object is intended to facilitate downstream analyses across multiple samples.

The libraries included in the merged object are _NOT integrated or batch-corrected_.
To conduct any downstream analyses that require batch correction (e.g., UMAP or clustering), batch correction must be performed separately. 

# Library statistics 

```{r}
# extract coldata as data frame to use to create tables
coldata_df <- colData(merged_sce) |>
  as.data.frame()

num_libraries <- merged_sce$library_id |>
  unique() |>
  length()
```

The merged object summarized in this report is comprised of `r num_libraries` individual libraries.
The following table shows a summary of the types of libraries represented.

- `Technology version` indicates which 10X Genomics kit was used for library preparation.
- `Experimental factor ontology` indicates the associated [Experimental factor ontology](https://www.ebi.ac.uk/efo/) (EFO) for the specified 10X version. 
- `Cell or Nucleus` indicates if the library was prepared from a single-cell (`cell`) or single-nuclei (`nucleus`) suspension. 


```{r}
# table summarizing number of libraries with tech version and seq unit
tech_table <- coldata_df |>
  dplyr::select(library_id, tech_version, assay_ontology_term_id, seq_unit) |>
  dplyr::distinct() |>
  dplyr::count(tech_version, assay_ontology_term_id, seq_unit) |>
  dplyr::arrange(desc(n)) |>
  dplyr::rename(
    "Technology version" = "tech_version",
    "Experimental factor ontology" = "assay_ontology_term_id",
    "Cell or Nucleus" = "seq_unit",
    "Number of libraries" = "n"
  )

knitr::kable(tech_table, align = "r") |>
  kableExtra::kable_styling(
    bootstrap_options = "striped",
    full_width = FALSE,
    position = "left"
  ) |>
  kableExtra::column_spec(2, monospace = TRUE)
```


```{r, eval=has_adt}
knitr::asis_output(glue::glue(
  "
  This merged object contains one or more libraries with accompanying ADT expression data.
  The table below summarizes the number of libraries with and without ADT data.
  "
))

# count number of libraries with and without ADT
adt_table <- coldata_df |>
  dplyr::select(library_id, additional_modalities) |>
  dplyr::distinct() |>
  dplyr::mutate(
    contains_adt = ifelse(additional_modalities == "adt", "Contains ADT", "No ADT")
  ) |>
  dplyr::count(contains_adt) |>
  dplyr::rename(
    "Library type" = "contains_adt",
    "Number of libraries" = "n"
  )

knitr::kable(adt_table, align = "r") |>
  kableExtra::kable_styling(
    bootstrap_options = "striped",
    full_width = FALSE,
    position = "left"
  ) |>
  kableExtra::column_spec(2, monospace = TRUE)
```


```{r, eval=is_multiplexed }
knitr::asis_output(glue::glue(
  "
  This merged object contains one or more libraries that have been multiplexed.
  The table below summarizes the number of libraries that have and have not been multiplexed.
  "
))

# count number of libraries with and without multiplexing
multiplex_table <- coldata_df |>
  dplyr::select(library_id, additional_modalities) |>
  dplyr::distinct() |>
  dplyr::mutate(
    is_multiplexed = ifelse(additional_modalities == "cellhash", "Multiplexed", "No multiplexing")
  ) |>
  dplyr::count(is_multiplexed) |>
  dplyr::rename(
    "Library type" = "is_multiplexed",
    "Number of libraries" = "n"
  )

knitr::kable(multiplex_table, align = "r") |>
  kableExtra::kable_styling(
    bootstrap_options = "striped",
    full_width = FALSE,
    position = "left"
  ) |>
  kableExtra::column_spec(2, monospace = TRUE)
```


# Sample statistics

```{r, results='asis'}
if (is_multiplexed) {
  glue::glue("
    <div class=\"alert alert-info\">

    The libraries included in the merged object are multiplexed.
    No demultiplexing has been done, so no sample statistics will be displayed.

    </div>
  ")
}
```


```{r, eval=!is_multiplexed}
# get total number of samples and libraries
num_samples <- merged_sce$sample_id |>
  unique() |>
  length()
```


```{r, eval=!is_multiplexed, results='asis'}
glue::glue(
  "
  The merged object summarized in this report contains {num_samples} samples.
  "
)
```

## Diagnoses

Below is a table showing the total number of samples associated with each diagnoses. 
If subdiagnosis is available, the total number of samples will be obtained for each unique combination of diagnosis and subdiagnosis. 

```{r, eval=!is_multiplexed}
# table of diagnosis
diagnosis_table <- coldata_df |>
  dplyr::select(sample_id, diagnosis, subdiagnosis) |>
  dplyr::distinct()

# if subdiagnosis is present, summarize both
if (!all(is.na(diagnosis_table$Subdiagnosis))) {
  diagnosis_table <- diagnosis_table |>
    dplyr::count(diagnosis, subdiagnosis) |>
    dplyr::arrange(desc(n)) |>
    dplyr::rename(
      "Diagnosis" = "diagnosis",
      "Subdiagnosis" = "subdiagnosis",
      "Number of samples" = "n"
    )
} else {
  # otherwise only count diagnosis
  diagnosis_table <- diagnosis_table |>
    dplyr::select(-subdiagnosis) |>
    dplyr::count(diagnosis) |>
    dplyr::arrange(desc(n)) |>
    dplyr::rename(
      "Diagnosis" = "diagnosis",
      "Number of samples" = "n"
    )
}

knitr::kable(diagnosis_table, align = "r") |>
  kableExtra::kable_styling(
    bootstrap_options = "striped",
    full_width = FALSE,
    position = "left"
  ) |>
  kableExtra::column_spec(2, monospace = TRUE)
```

## Disease stage 

The below table shows both the diagnosis and at what point during disease progression (`Disease stage`) the sample was taken. 

```{r, eval=!is_multiplexed}
# count number of samples per diagnosis/ disease timing combination
disease_timing_table <- coldata_df |>
  dplyr::select(sample_id, diagnosis, disease_timing) |>
  dplyr::distinct() |>
  dplyr::count(diagnosis, disease_timing) |>
  dplyr::arrange(desc(n)) |>
  dplyr::rename(
    "Diagnosis" = "diagnosis",
    "Disease stage" = "disease_timing",
    "Number of samples" = "n"
  )

knitr::kable(disease_timing_table, align = "r") |>
  kableExtra::kable_styling(
    bootstrap_options = "striped",
    full_width = FALSE,
    position = "left"
  ) |>
  kableExtra::column_spec(2, monospace = TRUE)
```


# Session Info
<details>
<summary>R session information</summary>
```{r session_info}
if (requireNamespace("sessioninfo", quietly = TRUE)) {
  sessioninfo::session_info()
} else {
  sessionInfo()
}
```
</details>
