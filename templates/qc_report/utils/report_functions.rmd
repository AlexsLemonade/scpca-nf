<!-- This document contains function definitions that are used by the
`main_qc_report.rmd` and child reports, but are not specific to cell typing.
-->


```{r}
#' Determine size for UMAP points which depends on the number of cells in the
#'   processed object.
#'
#' @param n_processed_cells Number of cells in the processed object
#'
#' @return A vector with two integer values: A standalone UMAP point size, and a
#'   point size for faceted UMAPs
determine_umap_point_size <- function(n_processed_cells) {
  umap_point_size <- dplyr::case_when(
    n_processed_cells <= 500 ~ 0.8,
    n_processed_cells <= 2250 ~ 0.6,
    .default = 0.3
  )
  umap_facet_point_size <- dplyr::case_when(
    n_processed_cells <= 500 ~ 0.5,
    n_processed_cells <= 2250 ~ 0.25,
    n_processed_cells <= 5000 ~ 0.1,
    .default = 0.01
  )

  return(c(umap_point_size, umap_facet_point_size))
}

#' Make UMAP colored by clusters
#'
#' @param sce SingleCellExperiment object with UMAP embeddings
#' @param point_size Point size. Default is 1
#'
#' @return UMAP plot as a ggplot2 object
#'
plot_clusters_umap <- function(
  sce,
  point_size = 1
) {
  # umap colored by clusters
  clusters_plot <- scater::plotUMAP(
    sce,
    point_size = umap_point_size,
    point_alpha = 0.5,
    colour_by = "cluster"
  ) +
    # remove axis numbers and background grid
    scale_x_continuous(labels = NULL, breaks = NULL) +
    scale_y_continuous(labels = NULL, breaks = NULL) +
    guides(
      color = guide_legend(
        title = "Cluster",
        nrow = 2,
        # more visible points in legend
        override.aes = list(
          alpha = 1,
          size = 1.5
        )
      )
    ) +
    theme_bw() +
    theme(
      legend.position = "bottom",
      aspect.ratio = 1
    )

  # Determine palette based on number of levels.
  # If we have <=8, we can use a CVD-friendly palette (they generally don't have more than 8 colors).
  #  Otherwise, we will use the default palette.
  if (length(levels(sce$cluster)) <= 8) {
    clusters_plot +
      scale_color_brewer(palette = "Set2")
  } else {
    clusters_plot
  }

  return(clusters_plot)
}
```

```{r}
#' Print table with sample metadata
#'
#' @param meta_list List of metadata from SCE object.
#'   Must contain `sample_metadata`.
#'
#' @return table with sample metadata

print_sample_metadata <- function(meta_list) {
  # get sample metadata as a data frame
  sample_metadata <- meta_list$sample_metadata

  # only print table if sample metadata is present
  if (!is.null(sample_metadata)) {
    # build urls using ontology terms
    # first create a tibble with term, human readable value, and ontology ID
    ontology_link_df <- tibble::tibble(
      term = c(
        "age",
        "sex",
        "organism",
        "diagnosis",
        "tissue_location"
      ),
      hr_value = c(
        ifelse("age" %in% names(sample_metadata), as.character(sample_metadata$age), "NA"),
        ifelse("sex" %in% names(sample_metadata), sample_metadata$sex, "NA"),
        ifelse("organism" %in% names(sample_metadata), sample_metadata$organism, "NA"),
        ifelse("diagnosis" %in% names(sample_metadata), sample_metadata$diagnosis, "NA"),
        ifelse("tissue_location" %in% names(sample_metadata), sample_metadata$tissue_location, "NA")
      ),
      ontology_term_id = c(
        ifelse(
          "development_stage_ontology_term_id" %in% names(sample_metadata),
          sample_metadata$development_stage_ontology_term_id,
          NA
        ),
        ifelse(
          "sex_ontology_term_id" %in% names(sample_metadata),
          sample_metadata$sex_ontology_term_id,
          NA
        ),
        ifelse(
          "organism_ontology_id" %in% names(sample_metadata),
          sample_metadata$organism_ontology_id,
          NA
        ),
        ifelse(
          "disease_ontology_term_id" %in% names(sample_metadata),
          sample_metadata$disease_ontology_term_id,
          NA
        ),
        ifelse(
          "tissue_ontology_term_id" %in% names(sample_metadata),
          sample_metadata$tissue_ontology_term_id,
          NA
        )
      )
    ) |>
      dplyr::mutate(
        # replace ID with _ to construct url
        ontology_term_id = stringr::str_replace(ontology_term_id, ":", "_"),
        # build url
        url = glue::glue("http://purl.obolibrary.org/obo/{ontology_term_id}"),
        # format linked url with hr value for table
        # if NA term ID, don't link
        url = dplyr::if_else(
          is.na(ontology_term_id),
          kableExtra::text_spec(hr_value, "html"),
          kableExtra::text_spec(hr_value, "html", link = url)
        )
      )

    # create a named list of urls to use for easy table building
    url_list <- as.list(ontology_link_df$url) |>
      purrr::set_names(ontology_link_df$term)

    # construct table to print
    # fill in with sample metadata information for non ontology IDs and use urls for all ontology IDs
    table <- tibble::tibble(
      "Sample ID" = sample_metadata$sample_id,
      "Diagnosis" = url_list$diagnosis,
      "Subdiagnosis" = ifelse(
        "subdiagnosis" %in% names(sample_metadata),
        sample_metadata$subdiagnosis,
        "NA"
      ),
      "Tissue location" = url_list$tissue_location,
      "Disease timing" = ifelse(
        "disease_timing" %in% names(sample_metadata),
        sample_metadata$disease_timing,
        "NA"
      ),
      "Age" = url_list$age,
      "Sex" = url_list$sex,
      "Organism" = url_list$organism,
      "Sample type" = ifelse(
        "sample_type" %in% names(meta_list),
        paste0(meta_list$sample_type, collapse = ", "),
        "NA"
      )
    ) |>
      t() |>
      # account for html links
      knitr::kable(format = "html", escape = FALSE, align = "r") |>
      kableExtra::kable_styling(
        bootstrap_options = "striped",
        full_width = FALSE,
        position = "left"
      ) |>
      kableExtra::column_spec(2, monospace = TRUE)

    return(table)
  } else {
    # if no sample metadata, print out a message
    knitr::asis_output(
      glue::glue("
    <div class=\"alert alert-info\">

    No sample metadata is available for this library.

    </div>
  ")
    )
  }
}
```

```{r}
#' Format DT datatables
#'
#' @param df Data frame to format
#'
#' @return DT datatable
format_datatable <- function(df) {
  df |>
    DT::datatable(
      rownames = FALSE,
      extensions = "Scroller",
      options = list(
        scroller = TRUE,
        deferRender = TRUE,
        scrollX = TRUE,
        scrollY = 400,
        scrollCollapse = TRUE,
        language = list(search = "Filter:"),
        columnDefs = list(list(
          # render missing values as "NA" rather than blanks in the table
          targets = "_all",
          render = DT::JS(
            "function(data, type, row, meta) {",
            "return data === null ? 'NA' : data;",
            "}"
          )
        ))
      )
    )
}
```
