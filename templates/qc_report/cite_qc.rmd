# CITE-seq Experiment Summary

This section details quality control statistics from the ADT (antibody-derived tag) component of CITE-seq experiments.

## CITE-seq Experiment Statistics

```{r}
# add rowData if missing
if (is.null(rowData(adt_exp)$detected)){
  adt_exp <- scuttle::addPerFeatureQCMetrics(adt_exp)
}

cell_adt_counts <- Matrix::colSums(counts(adt_exp))

adt_information <- tibble::tibble(
  "Number of ADTs assayed" =
    format(nrow(adt_exp), big.mark = ',', scientific = FALSE),
  "Number of reads sequenced" =
    format(adt_meta$total_reads, big.mark = ',', scientific = FALSE),
  "Percent reads mapped to ADTs" =
    paste0(round(adt_meta$mapped_reads/adt_meta$total_reads * 100, digits = 2), "%"),
  "Percent of ADTs in cells" =
    paste0(round(sum(cell_adt_counts)/adt_meta$mapped_reads * 100, digits = 2), "%"),
  "Percent of cells with ADTs" =
    paste0(round(sum(cell_adt_counts > 0)/length(cell_adt_counts) * 100, digits = 2), "%"),
  "Median ADT UMIs per cell" =
    format(median(cell_adt_counts), big.mark = ',', scientific = FALSE)
  )|>
  t()

knitr::kable(adt_information, align = 'r') |>
  kableExtra::kable_styling(bootstrap_options = "striped",
                            full_width = FALSE,
                            position = "left") |>
  kableExtra::column_spec(2, monospace = TRUE)
```

## ADT Statistics
```{r}
antibody_tags <- as.data.frame(rowData(adt_exp)) |>
  tibble::rownames_to_column("Antibody") |>
  arrange(desc(mean)) |>
  select("Antibody",
         "Mean UMI count per cell" = mean,
         "Percent of cells detected" = detected,
         "ADT target type" =  target_type)

knitr::kable(antibody_tags, digits = 2) |>
  kableExtra::kable_styling(bootstrap_options = c("striped", "condensed"),
                            full_width = FALSE,
                            position = "left",
                            ) 
```

## ADT Post-processing Statistics

```{r}

filtered_cell_count <- sum(filtered_sce$adt_scpca_filter == "Remove")

basic_statistics <- tibble::tibble(
    "Method used to identify cells targeted for filtering" = format(processed_meta$adt_scpca_filter_method),
    "Number of cells targeted for filtering"  = format(filtered_cell_count),
    "Percent of cells targeted for filtering" =
      paste0(round(filtered_cell_count/nrow(processed_sce) * 100, digits = 2), "%")
  ) |>
  mutate(across(.fns = ~ifelse(.x == "NULL", "N/A", .x))) |> # reformat nulls
  t()

knitr::kable(basic_statistics, align = 'r') |>
  kableExtra::kable_styling(bootstrap_options = "striped",
                            full_width = FALSE,
                            position = "left") |>
  kableExtra::column_spec(2, monospace = TRUE)
```


## Expression of highly variable ADTs

The plots below show UMAP embeddings calculated from RNA expression where each cell is colored by the expression level of the labeled 
ADT. 
The ADTs chosen for plotting are the top 4 most variable ADTs in the library.


```{r fig.height=5, fig.width=6, message=FALSE, results='asis'}
# only create plot if variable ADTs are present
if (!is.null(processed_meta$highly_variable_adts)) {
  
  # select top ADTs to plot 
  top_adts <- processed_meta$highly_variable_adts |>
    head(n = 4)
  
  # grab expression for top ADTs from counts
  var_adt_exp <- logcounts(adt_exp[top_adts,]) |>
    as.matrix() |>
    t() |>
    as.data.frame() |>
    tibble::rownames_to_column("barcode")
  
  # extract umap embeddings as a dataframe
  umap_df <- reducedDim(processed_sce, "UMAP") |>
    as.data.frame() |>
    tibble::rownames_to_column("barcode") |>
    rename("UMAP1" = "V1",
           "UMAP2" = "V2") 
  
  # combine ADT expression with coldata, umap embeddings, and create data frame to use for plotting
  coldata_df <- colData(processed_sce) |>
    as.data.frame() |>
    tibble::rownames_to_column("barcode") |>
    # TODO: FILTER TO ONLY ADTS WHOSE KEEP==TRUE???
    # combine with gene expression
    left_join(var_adt_exp, by = "barcode") |>
    # combine with umap embeddings 
    left_join(umap_df, by = "barcode") |>
    # combine all ADTs into a single column for easy faceting 
    tidyr::pivot_longer(cols = starts_with("CD"),
                        names_to = "ADT",
                        values_to = "adt_expression")
  
  
  ggplot(coldata_df, aes(x = UMAP1, y = UMAP2, color = adt_expression)) + 
    geom_point(alpha = 0.1, size = 0.075) + 
    facet_wrap(vars(ADT)) +
    scale_color_viridis_c() +
    labs(
      color = "Log-normalized ADT expression"
    ) +
    theme(legend.position = "bottom", 
          axis.text = element_text(size = 8, color = "black"),
          axis.title = element_text(size = 8, color = "black"),
          strip.text = element_text(size = 8),
          strip.background = element_rect(fill = 'transparent'),
          legend.title = element_text(size = 8),
          legend.text = element_text(size = 8)) + 
    guides(colour = guide_colorbar(title.position = "bottom", title.hjust = 0.5))
  
} else {
  glue::glue("
    <div class=\"alert alert-warning\">
    
    This library does not contain a set of highly variable ADTs. 
    
    </div>
  ")
}
```

