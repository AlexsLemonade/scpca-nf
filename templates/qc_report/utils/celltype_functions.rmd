<!-- This document contains function definitions that are used by both
`main_qc_report.rmd` and `celltypes_supplemental_report.rmd` to prepare
cell typing results for analysis/visualization -->


```{r}
library(SingleCellExperiment)

#' Create `celltype_df` data frame for use in cell type QC reports
#'
#' @param processed_sce The processed sce object with cell type annotations in colData
#'
#' @return `celltype_df` with column of cell types, as factors, for each annotation method
create_celltype_df <- function(processed_sce) {
  celltype_df <- processed_sce |>
    scuttle::makePerCellDF(use.dimred = "UMAP") |>
    # rename UMAP columns as needed to remove potential period added by `scuttle::makePerCellDF`
    dplyr::rename_with(
      \(x) stringr::str_replace(x, "^UMAP\\.", "UMAP"),
      starts_with("UMAP")
    ) |>
    # only keep columns of interest
    dplyr::select(
      barcodes,
      cluster,
      contains("UMAP"),
      contains("singler"),
      contains("cellassign"),
      contains("submitter")
    )

  if ("submitter_celltype_annotation" %in% names(celltype_df)) {
    celltype_df <- celltype_df |>
      prepare_annotation_values(submitter_celltype_annotation, is_submitter = TRUE)
  }

  if ("singler_celltype_annotation" %in% names(celltype_df)) {
    celltype_df <- celltype_df |>
      prepare_annotation_values(singler_celltype_annotation)
  }
  if ("cellassign_celltype_annotation" %in% names(celltype_df)) {
    celltype_df <- celltype_df |>
      prepare_annotation_values(cellassign_celltype_annotation)
  }

  return(celltype_df)
}

# Functions for working with cell type annotations in QC reports

#' Prepare and reformat cell type annotation values for use in QC reports
#'  Unknown cell types are updated with the label "Unknown cell type", and
#'  cell types are ordered in order of descending frequency, but with
#'  "Unknown cell type" as the last level
#'
#' @param df The data frame containing cell type annotations, one row per cell
#' @param annotation_column The column (written plainly, not a string) containing annotations to reformat
#' @param is_submitter Boolean indicating if cell types are from submitter.
#'   If TRUE, NA's will be set to "Unclassified cell".
#'   If FALSE, NA's will be set to "Unknown cell type". Default is FALSE
#'
#' @return Updated data frame with the `annotation_column` reformatted
prepare_annotation_values <- function(
    df,
    annotation_column,
    is_submitter = FALSE) {
  
  # used for SingleR and CellAssign unknowns
  automated_unknown_string <- "Unknown cell type"
  
  # used for submitter unknowns - strings which might be "unknown"-y
  submitter_unknown_strings <- c("na", "n/a", "<na>", "<n/a>", "null", "unknown", " ")
  # define variations here rather than lowering the submitter annotations themselves
  submitter_unknown_strings <- c(
    submitter_unknown_strings,
    stringr::str_to_upper(submitter_unknown_strings), 
    stringr::str_to_title(submitter_unknown_strings)
  ) |>
    unique()
  
  # string for submitter-excluded cell types
  submitter_excluded_string <- "Submitter-excluded"
    
    
  df <- df |>
     dplyr::mutate(
       {{ annotation_column }} := dplyr::case_when(
         # submitter condition - HAS TO BE FIRST since these are also NA which is the singler check
         #is_submitter & is.na({{ annotation_column }}) ~ submitter_string,
         # singler condition
         is.na({{ annotation_column }}) ~ automated_unknown_string,
         # cellassign conditon
         {{ annotation_column }} == "other" ~  automated_unknown_string,
         # otherwise, keep it
         .default = {{ annotation_column }}
       ) 
     )

  if (is_submitter) {
    
    # we'll directly use the `submitter_celltype_annotation` name here for the 
    # column since we know we're working with submitter annotations 
    
    # determine and order which unknown types are present
    present_unknown_strings <- df |>
      dplyr::filter(submitter_celltype_annotation %in% submitter_unknown_strings) |>
      dplyr::count(submitter_celltype_annotation, sort = TRUE) |>
      dplyr::pull(submitter_celltype_annotation) |>
      as.character()
    
    # submitter exlcuded strings go at the VERY END regardless of count
    if (submitter_excluded_string %in% unique(df$submitter_celltype_annotation)) {
      present_unknown_strings <- c(present_unknown_strings, submitter_excluded_string)
    }
    
    # define new levels by moving any unknowns to the end
    submitter_levels <- levels(df$submitter_celltype_annotation)
    new_submitter_levels <- c(
      submitter_levels[!(submitter_levels %in% present_unknown_strings)], 
      present_unknown_strings
    )
    
    # apply new levels
    df$submitter_celltype_annotation <- as.character(df$submitter_celltype_annotation) # defactor first, in case...
    df$submitter_celltype_annotation <- factor(
      df$submitter_celltype_annotation, 
      levels = new_submitter_levels
    )
    
  } else {
    
    df <- df |>
      # order column by number of cells
      forcats::fct_infreq() |>
      # make "Unknown cell type" the last level
      dplyr::mutate(
        {{ annotation_column }} := forcats::fct_relevel("Unknown cell type", after = Inf)
      )
  }

  # return the updated data frame
  return(df)  
}
```

