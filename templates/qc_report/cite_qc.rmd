# CITE-seq Experiment Summary

This section details quality control statistics from the ADT (antibody-derived tag) component of CITE-seq experiments.

## CITE-seq Experiment Statistics

```{r}
# add rowData if missing
if (is.null(rowData(adt_exp)$detected)){
  adt_exp <- scuttle::addPerFeatureQCMetrics(adt_exp)
}

cell_adt_counts <- Matrix::colSums(counts(adt_exp))

adt_information <- tibble::tibble(
  "Number of ADTs assayed" =
    format(nrow(adt_exp), big.mark = ',', scientific = FALSE),
  "Number of reads sequenced" =
    format(adt_meta$total_reads, big.mark = ',', scientific = FALSE),
  "Percent reads mapped to ADTs" =
    paste0(round(adt_meta$mapped_reads/adt_meta$total_reads * 100, digits = 2), "%"),
  "Percent of ADTs in cells" =
    paste0(round(sum(cell_adt_counts)/adt_meta$mapped_reads * 100, digits = 2), "%"),
  "Percent of cells with ADTs" =
    paste0(round(sum(cell_adt_counts > 0)/length(cell_adt_counts) * 100, digits = 2), "%"),
  "Median ADT UMIs per cell" =
    format(median(cell_adt_counts), big.mark = ',', scientific = FALSE)
  )|>
  t()

knitr::kable(adt_information, align = 'r') |>
  kableExtra::kable_styling(bootstrap_options = "striped",
                            full_width = FALSE,
                            position = "left") |>
  kableExtra::column_spec(2, monospace = TRUE)
```

## ADT Statistics
```{r}
antibody_tags <- as.data.frame(rowData(adt_exp)) |>
  tibble::rownames_to_column("Antibody") |>
  arrange(desc(mean)) |>
  select("Antibody",
         "Mean UMI count per cell" = mean,
         "Percent of cells detected" = detected,
         "ADT target type" =  target_type)

knitr::kable(antibody_tags, digits = 2) |>
  kableExtra::kable_styling(bootstrap_options = c("striped", "condensed"),
                            full_width = FALSE,
                            position = "left",
                            ) 
```

## ADT Post-processing Statistics

Note that low-quality cells as identified by ADT counts are not actually filtered from the SCE object.
Instead, cells that passed the filter threshold are labeled as `"Keep"` within the SCE object, and conversely cells that failed to pass the filtered are labeled as `"Remove"`.

```{r}
if (has_processed) {
  filtered_cell_count <- sum(processed_sce$adt_scpca_filter == "Keep")
  
  basic_statistics <- tibble::tibble(
    # Note that the adt_scpca_filter_method column is only present in the processed_sce object
    "Method used to identify cells to filter" = format(processed_meta$adt_scpca_filter_method),
    "Number of cells that pass filtering threshold"  = format(filtered_cell_count),
    "Percent of cells that pass filtering threshold" =
        paste0(round(filtered_cell_count/nrow(processed_sce) * 100, digits = 2), "%")
    ) |>
    mutate(across(.fns = ~ifelse(.x == "NULL", "N/A", .x))) |> # reformat nulls
    t()
  
  knitr::kable(basic_statistics, align = 'r') |>
    kableExtra::kable_styling(bootstrap_options = "striped",
                              full_width = FALSE,
                              position = "left") |>
    kableExtra::column_spec(2, monospace = TRUE)
} else {
    glue::glue("
    <div class=\"alert alert-warning\">

    No ADT post-processing was performed on this library.

    </div>
  ")
}

```


## Expression of highly variable ADTs

The plots below show visualizations of the top 4 most variable ADTS in the library.

First, ridgeplots showing normalized expression of these 4 ADTs are shown.
Second, UMAP embeddings calculated from RNA expression are shown, where each cell is colored by the expression level of the given ADT. 


```{r fig.height=10, fig.width=8, message=FALSE, warning=FALSE, results='asis'}
if (has_processed) {
  
  # only create plot if variable ADTs are present
  if (!is.null(processed_meta$highly_variable_adts)) {
    
    adt_exp_processed <- altExp(processed_sce)
    
    # select top ADTs to plot 
    top_adts <- processed_meta$highly_variable_adts |>
      head(n = 4)
    
    # grab expression for top ADTs from counts
    var_adt_exp_df <- logcounts(adt_exp_processed[top_adts,]) |>
      as.matrix() |>
      t() |>
      as.data.frame() |>
      tibble::rownames_to_column("barcode") |>
      # combine all ADTs into a single column for easy faceting 
      tidyr::pivot_longer(cols = starts_with("CD"),
                            names_to = "ADT",
                            values_to = "adt_expression")
    
    # First, expression ridgeplot ridgeplots
    adt_ridgeplot <- ggplot(var_adt_exp_df, 
           aes(y = ADT, x = adt_expression, fill = ADT)) + 
      ggridges::geom_density_ridges(alpha = 0.5) + 
      scale_fill_viridis_d() + 
      labs(x = "Log-normalized ADT expression") +
      theme(legend.position = "none") 
    
    
    # Next, extract umap embeddings as a dataframe
    umap_df <- reducedDim(processed_sce, "UMAP") |>
      as.data.frame() |>
      tibble::rownames_to_column("barcode") |>
      rename("UMAP1" = "V1",
             "UMAP2" = "V2") 
    
    # combine ADT expression with coldata, umap embeddings, and create data frame to use for plotting
    coldata_df <- colData(processed_sce) |>
      as.data.frame() |>
      tibble::rownames_to_column("barcode") |>
      # combine with gene expression
      left_join(var_adt_exp_df, by = "barcode") |>
      # combine with umap embeddings 
      left_join(umap_df, by = "barcode")
    
    
    adt_umap <- ggplot(coldata_df, aes(x = UMAP1, y = UMAP2, color = adt_expression)) + 
      geom_point(alpha = 0.1, size = 0.1) + 
      facet_wrap(vars(ADT)) +
      scale_color_viridis_c() +
      labs(
        color = "Log-normalized ADT expression"
      ) +
      theme(legend.position = "bottom", 
            axis.text = element_text(size = 8, color = "black"),
            axis.title = element_text(size = 8, color = "black"),
            strip.text = element_text(size = 8),
            strip.background = element_rect(fill = 'transparent'),
            legend.title = element_text(size = 8),
            legend.text = element_text(size = 8)) + 
      guides(colour = guide_colorbar(title.position = "bottom", title.hjust = 0.5)) 
    
    # Combine with patchwork so that both plots are reliably printed
    adt_ridgeplot / adt_umap
    
  } else {
    glue::glue("
      <div class=\"alert alert-warning\">
      
      This library does not contain a set of highly variable ADTs. 
      
      </div>
    ")
  }
} else {
  glue::glue("
    <div class=\"alert alert-warning\">

    No ADT post-processing was performed on this library.

    </div>
  ")
}
```

