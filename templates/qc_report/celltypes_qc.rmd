# Cell type Annotation Summary

```{r}
## function definitions ##

# Source functions for preparing cell type data
source(file.path("qc_utils", "celltype_functions.R"))

#' Create tables of cell type annotation counts
#'
#' @param df Data frame with cell types
#' @param celltype_column Column with cell type annotations, not a string.
#'
#' @return kableExtra table with cell type counts.
create_celltype_n_table <- function(df, celltype_column) {
  df |>
    dplyr::count({{ celltype_column }}) |>
    # Add percentage column
    dplyr::mutate(
      `Percent of cells` = paste0(round(n / sum(n) * 100, digits = 2), "%")
    ) |>
    # set column order & rename
    dplyr::select(
      `Annotated cell type` = {{ celltype_column }},
      `Number of cells` = n,
      `Percent of cells`
    ) |>
    # kable formatting
    knitr::kable(align = "r") |>
    kableExtra::kable_styling(
      bootstrap_options = "striped",
      full_width = FALSE,
      position = "left"
    ) |>
    kableExtra::column_spec(2, monospace = TRUE)
}


# Function to add a column of lumped cell types in a data frame
#'
#' @param df Data frame to manipulate
#' @param celltype_df Data frame that contains column of cell types,
#'   named `{celltype_method}_celltype_annotation`
#' @param celltype_method Cell type method
#' @param n_celltypes Number of groups to lump into, with rest put into "Other" group. Default is 7.
#'
#' @return Updated df with new column of lumped celltypes called `{celltype_method}`
lump_celltypes <- function(df,
                           celltype_df,
                           celltype_method,
                           n_celltypes = 7) {
  df |>
    dplyr::mutate(
      celltypes = celltype_df[[glue::glue("{celltype_method}_celltype_annotation")]] |>
        forcats::fct_lump_n(
          n_celltypes,
          other_level = "Other cell type"
        )
    ) |>
    # finally, rename temporary `celltypes` column to the provided method
    dplyr::rename({{ celltype_method }} := celltypes)
}




#' Make UMAP  colored by given variable
#'
#' @param umap_df Data frame with UMAP1 and UMAP2 columns
#' @param color_variable Column in data frame to color by, not a string.
#' @param legend_title Title for legend.
#' @param legend_nrow Number of rows in legend. Default is 2.
#'
#' @return UMAP plot as a ggplot2 object
plot_umap <- function(umap_df,
                      color_variable,
                      legend_title,
                      legend_nrow = 2) {
  ggplot(umap_df) +
    aes(
      x = UMAP1,
      y = UMAP2,
      color = {{ color_variable }}
    ) +
    geom_point(
      size = 0.3,
      alpha = 0.5
    ) +
    # remove axis numbers and background grid
    scale_x_continuous(labels = NULL, breaks = NULL) +
    scale_y_continuous(labels = NULL, breaks = NULL) +
    coord_fixed() +
    guides(
      color = guide_legend(
        title = legend_title,
        nrow = legend_nrow,
        # more visible points in legend
        override.aes = list(
          alpha = 1,
          size = 1.5
        )
      )
    ) +
    theme(legend.position = "bottom")
}
```


<!-- Background depends on which cell types are present in the SCE. -->


<!-- Submitter _only_ --> 
```{r, eval = has_submitter & !(has_singler | has_cellassign)}
knitr::asis_output(
  glue::glue("
  This section details cell type annotations provided by the original lab ('submitter') which generated this data.
  ")
)
```


<!-- At least one cell type annotation method. --> 
```{r, eval = has_singler | has_cellassign}
knitr::asis_output(
  glue::glue("
  This section details results from performing cell type annotation.
  The following method(s) were used to perform cell typing:
 ")
)
```


```{r, eval = has_singler}
knitr::asis_output(
  glue::glue(
  "* [`SingleR`](https://bioconductor.org/packages/release/bioc/html/SingleR.html), which uses a reference-based approach.
  The `{metadata(processed_sce)$singler_reference}` reference dataset, obtained from the [`celldex` package](http://bioconductor.org/packages/release/data/experiment/html/celldex.html) package, was used for cell typing."
  )
)
```


```{r, eval = has_cellassign}
knitr::asis_output(
  glue::glue(
  "* [`CellAssign`](https://github.com/Irrationone/cellassign), which uses a marker-gene based approach.
  Marker genes associated with `{metadata(processed_sce)$cellassign_reference}` tissue were obtained from [PanglaoDB](https://panglaodb.se/).
  "
  )
)
```


<!-- Submitter and at least one inference method --> 
```{r, eval = has_submitter & (has_singler | has_cellassign)}
knitr::asis_output(
  glue::glue(
  "* Cell type annotations were also provided by the original lab (`submitter-provided`) which generated this data. 
  "
  )
)
```

For additional information about cell typing, including diagnostic plots and/or heatmap comparisons among annotations (if available), please refer to the [supplementary cell type QC report](`r glue::glue("{library_id}_supplemental_celltypes_report.html")`).


## Statistics

Below, cells labeled as "Unknown cell type" are those which could not be confidently identified using the given annotation method.


```{r}
# Create data frame of cell types
celltype_df <- create_celltype_df(processed_sce, has_singler, has_cellassign)
```


```{r, eval = has_singler}
knitr::asis_output("### `SingleR` cell type annotations\n")
create_celltype_n_table(celltype_df, singler_celltype_annotation)
```

```{r, eval = has_cellassign}
knitr::asis_output("### `CellAssign` cell type annotations\n")
create_celltype_n_table(celltype_df, cellassign_celltype_annotation)
```

```{r, eval = has_submitter}
knitr::asis_output('
### Submitter-provided cell type annotations\n

Below, cells labeled "Unclassified cell" are those for which submitters did not provide an annotation. 
  ')
create_celltype_n_table(celltype_df, submitter_celltype_annotation)
```

## UMAPs

In this section, we show UMAPs colored by clusters and cell types.
A separate UMAP is shown for each cell typing method used.
Clusters were calculated using the graph-based `r metadata(processed_sce)$cluster_algorithm` algorithm with `r metadata(processed_sce)$cluster_weighting` weights.

For legibility, only the seven most common cell types are shown.
All other cell types are grouped together and labeled "Other cell type" (not to be confused with "Unknown cell types," which represent cells that could not be classified).


```{r}
# Create dataset for plotting UMAPs with lumped cell types
umap_df <- tibble::as_tibble(
  reducedDim(processed_sce, "UMAP")
) |>
  dplyr::mutate(clusters = processed_sce$clusters)

if (has_singler) {
  umap_df <- lump_celltypes(umap_df, celltype_df, "singler")
}
if (has_cellassign) {
  umap_df <- lump_celltypes(umap_df, celltype_df, "cellassign")
}
if (has_submitter) {
  umap_df <- lump_celltypes(umap_df, celltype_df, "submitter")
}
```


<!-- First UMAP: clusters -->
```{r message=FALSE, warning=FALSE}
clusters_plot <- plot_umap(
  umap_df,
  clusters,
  "Clusters"
) +
  ggtitle("UMAP colored by clusters")

# Determine palette based on number of levels.
# If we have <=8, we can use a CVD-friendly palette (they generally don't have more than 8 colors).
#  Otherwise, we will use the default palette.
if (length(levels(umap_df$clusters)) <= 8) {
  clusters_plot +
    scale_color_brewer(palette = "Set2")
} else {
  clusters_plot
}
```

<!-- Now, UMAPs of cell types, where present -->

```{r eval=has_singler, message=FALSE, warning=FALSE}
plot_umap(umap_df,
  singler,
  "Cell types",
  legend_nrow = 4
) +
  ggtitle("UMAP colored by SingleR annotations") +
  scale_color_brewer(palette = "Dark2")
```


```{r, eval = has_cellassign, message=FALSE, warning=FALSE}
plot_umap(umap_df,
  cellassign,
  "Cell types",
  legend_nrow = 4
) +
  ggtitle("UMAP colored by CellAssign annotations") +
  scale_color_brewer(palette = "Dark2")
```


```{r eval = has_submitter, message=FALSE, warning=FALSE}
plot_umap(umap_df,
  submitter,
  "Cell types",
  legend_nrow = 4
) +
  ggtitle("UMAP colored by submitter-provided annotations") +
  scale_color_brewer(palette = "Dark2")
```
